<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dogfight 2 - Aerial Combat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #2a3a2a;
            color: #eee;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #4a5a3a;
            background: #3d5235;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            min-width: 250px;
        }

        #executeButton {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
            font-family: 'Courier New', monospace;
        }

        #restartButton, #pauseButton, #settingsButton {
            position: absolute;
            top: 10px;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        #restartButton { right: 180px; }
        #pauseButton { right: 100px; }
        #settingsButton { right: 10px; }

        #restartButton:hover, #pauseButton:hover, #settingsButton:hover {
            background: #1a4d7a;
        }

        #settingsPanel, #missionBriefing, #aircraftSelector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #0f3460;
            display: none;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
        }

        .panel-title {
            font-size: 24px;
            color: #e94560;
            margin-bottom: 20px;
            text-align: center;
        }

        .setting-row {
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .setting-label {
            font-size: 14px;
            color: #eee;
        }

        select, input[type="range"] {
            background: #2a3a2a;
            color: #eee;
            border: 1px solid #0f3460;
            padding: 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .minimap {
            position: absolute;
            bottom: 100px;
            right: 10px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f3460;
            border-radius: 5px;
        }

        .btn {
            padding: 10px 20px;
            margin: 5px;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .btn:hover {
            background: #1a4d7a;
        }

        .btn-primary {
            background: #e94560;
        }

        .btn-primary:hover {
            background: #c23555;
        }

        #energyDiagram {
            position: absolute;
            bottom: 320px;
            right: 10px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f3460;
            border-radius: 5px;
        }

        #splashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a1f3f 0%, #1a3a5a 50%, #0a1f3f 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .splash-title {
            font-size: 72px;
            color: #e94560;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            margin-bottom: 20px;
            font-weight: bold;
        }

        .splash-subtitle {
            font-size: 24px;
            color: #aaa;
            margin-bottom: 50px;
        }

        .game-mode-btn {
            width: 300px;
            padding: 20px;
            margin: 15px;
            background: rgba(15, 52, 96, 0.8);
            color: white;
            border: 2px solid #0f3460;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            transition: all 0.3s;
        }

        .game-mode-btn:hover {
            background: rgba(233, 69, 96, 0.8);
            border-color: #e94560;
            transform: scale(1.05);
        }

        .mode-description {
            font-size: 12px;
            color: #ccc;
            margin-top: 8px;
        }

        .replay-controls {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
        }

        #executeButton:hover {
            background: #c23555;
        }

        #executeButton:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #replayButton, .nextPhaseButton {
            position: absolute;
            bottom: 30px;
            padding: 15px 20px;
            font-size: 14px;
            font-weight: bold;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
            font-family: 'Courier New', monospace;
        }

        #replayButton {
            left: 50%;
            transform: translateX(-320px);
        }

        #nextPhase2s {
            left: 50%;
            transform: translateX(-140px);
        }

        #nextPhase4s {
            left: 50%;
            transform: translateX(10px);
        }

        #nextPhase6s {
            left: 50%;
            transform: translateX(160px);
        }

        #nextPhase8s {
            left: 50%;
            transform: translateX(310px);
        }

        #replayButton:hover, .nextPhaseButton:hover {
            background: #1a4d7a;
        }

        .warning {
            color: #e94560;
            font-weight: bold;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            50% { opacity: 0.3; }
        }

        .stat-line {
            margin: 5px 0;
            font-size: 14px;
        }

        .ghost-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border: 2px solid #0f3460;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            display: none;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 20px;
            color: #e94560;
        }

        h2 {
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 16px;
            color: #0f9d58;
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen">
        <div class="splash-title">DOGFIGHT 2</div>
        <div class="splash-subtitle">WW2 Aerial Combat Simulator</div>
        <button class="game-mode-btn" onclick="startQuickBattle()">
            <div>‚ö° QUICK BATTLE</div>
            <div class="mode-description">Spitfire vs Me-109 - Classic dogfight</div>
        </button>
        <button class="game-mode-btn" onclick="startCampaign()">
            <div>üéñÔ∏è CAMPAIGN MODE</div>
            <div class="mode-description">10 sequential missions with progression</div>
        </button>
        <button class="game-mode-btn" onclick="showAircraftSelector()">
            <div>üõ©Ô∏è CUSTOM BATTLE</div>
            <div class="mode-description">Choose your aircraft and enemy</div>
        </button>
    </div>

    <div id="gameContainer" style="display: none;">
        <canvas id="gameCanvas" width="1800" height="1000"></canvas>

        <div id="ui">
            <h1>DOGFIGHT 2</h1>
            <div id="phaseDisplay" class="stat-line">Phase: <span id="currentPhase">ORDER</span></div>
            <div id="turnDisplay" class="stat-line">Turn: <span id="currentTurn">1</span></div>

            <h2>Spitfire (You)</h2>
            <div id="spitfireStats"></div>

            <h2>Me-109 (Enemy)</h2>
            <div id="me109Stats"></div>

            <div style="margin-top: 15px; font-size: 11px; color: #888;">
                <div>Controls:</div>
                <div>‚Ä¢ Click aircraft to order</div>
                <div>‚Ä¢ Move mouse to position</div>
                <div>‚Ä¢ Mouse wheel: zoom in/out</div>
                <div>‚Ä¢ W/S: throttle up/down</div>
                <div>‚Ä¢ Q/E: altitude down/up</div>
                <div>‚Ä¢ A/D: slip/skid left/right</div>
                <div>‚Ä¢ R: cycle roll (none/half/full)</div>
                <div>‚Ä¢ I: Immelmann turn</div>
                <div>‚Ä¢ T: Split-S</div>
                <div>‚Ä¢ L: Loop</div>
                <div>‚Ä¢ H: Half-loop</div>
                <div>‚Ä¢ Z/X: fire threshold down/up</div>
                <div>‚Ä¢ Click again to lock</div>
                <div style="margin-top: 10px; color: #88ff88;">Wingman Commands:</div>
                <div>‚Ä¢ 1: Attack my target</div>
                <div>‚Ä¢ 2: Cover me</div>
                <div>‚Ä¢ 3: Break and attack</div>
                <div>‚Ä¢ 4: Rejoin formation</div>
                <div>‚Ä¢ 5: Free hunt</div>
                <div>‚Ä¢ F: Cycle formation</div>
            </div>
            <div id="squadronStatus" style="margin-top: 15px; font-size: 11px; color: #88ff88; display: none;">
                <div style="font-weight: bold;">Squadron Status:</div>
                <div id="formationDisplay"></div>
                <div id="wingmanCount"></div>
                <div id="formationBonusDisplay"></div>
            </div>
        </div>

        <div id="ghostPanel" class="ghost-panel"></div>

        <div id="realisticModeToggle" style="position: absolute; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px;">
            <label style="cursor: pointer; font-size: 14px;">
                <input type="checkbox" id="realisticModeCheckbox" style="margin-right: 8px; cursor: pointer;">
                Realistic AI Display
            </label>
            <div style="font-size: 11px; color: #aaa; margin-top: 5px; max-width: 200px;">
                Shows AI prediction based on last turn instead of actual planned move
            </div>
        </div>

        <button id="executeButton">EXECUTE ORDERS</button>
        <button id="replayButton">REPLAY</button>
        <button id="nextPhase2s" class="nextPhaseButton">NEXT PHASE (2s)</button>
        <button id="nextPhase4s" class="nextPhaseButton">NEXT PHASE (4s)</button>
        <button id="nextPhase6s" class="nextPhaseButton">NEXT PHASE (6s)</button>
        <button id="nextPhase8s" class="nextPhaseButton">NEXT PHASE (8s)</button>

        <button id="restartButton">RESTART</button>
        <button id="pauseButton">PAUSE</button>
        <button id="settingsButton">SETTINGS</button>

        <canvas id="minimap" class="minimap" width="200" height="200"></canvas>
        <canvas id="energyDiagram" width="200" height="200"></canvas>

        <!-- Replay Controls (Enhancement #10) -->
        <div id="replayControls" class="replay-controls">
            <button class="btn" onclick="replaySeek(-10)">‚è™ -10s</button>
            <button class="btn" onclick="toggleReplayPause()" id="replayPauseBtn">‚è∏ Pause</button>
            <button class="btn" onclick="replaySeek(10)">‚è© +10s</button>
            <button class="btn" onclick="toggleFreeCam()">üì∑ Free Cam</button>
            <button class="btn" onclick="exitReplay()">Exit Replay</button>
        </div>

        <!-- Settings Panel -->
        <div id="settingsPanel">
            <div class="panel-title">SETTINGS</div>
            <div class="setting-row">
                <span class="setting-label">Game Mode:</span>
                <select id="gameModeSelect">
                    <option value="arcade">Arcade</option>
                    <option value="realistic">Realistic</option>
                    <option value="simulation">Simulation</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">Sound Volume:</span>
                <input type="range" id="volumeSlider" min="0" max="100" value="70">
            </div>
            <div class="setting-row">
                <span class="setting-label">Difficulty:</span>
                <select id="difficultySelect">
                    <option value="easy">Easy</option>
                    <option value="normal" selected>Normal</option>
                    <option value="hard">Hard</option>
                    <option value="ace">Ace</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">Weather:</span>
                <select id="weatherSelect">
                    <option value="clear" selected>Clear</option>
                    <option value="wind">Windy</option>
                    <option value="rain">Rain</option>
                    <option value="storm">Storm</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">Multiplayer:</span>
                <select id="multiplayerSelect">
                    <option value="single">Single Player</option>
                    <option value="hotseat">Hot-seat (2 Players)</option>
                </select>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn btn-primary" onclick="closeSettings()">CLOSE</button>
            </div>
        </div>

        <!-- Mission Briefing Panel -->
        <div id="missionBriefing">
            <div class="panel-title">MISSION BRIEFING</div>
            <div id="briefingContent"></div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn btn-primary" onclick="startMission()">START MISSION</button>
            </div>
        </div>

        <!-- Aircraft Selector Panel -->
        <div id="aircraftSelector">
            <div class="panel-title">AIRCRAFT SELECTION</div>
            <div class="setting-row">
                <span class="setting-label">Your Aircraft:</span>
                <select id="playerAircraftSelect">
                    <option value="Spitfire">Supermarine Spitfire</option>
                    <option value="Me-109">Messerschmitt Bf 109</option>
                    <option value="P-51">P-51D Mustang</option>
                    <option value="P-47">P-47D Thunderbolt</option>
                    <option value="Hurricane">Hawker Hurricane</option>
                    <option value="P-40">P-40 Warhawk</option>
                    <option value="Fw-190">Focke-Wulf Fw 190</option>
                    <option value="Me-262">Me 262 Jet</option>
                    <option value="Zero">A6M Zero</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">Enemy Aircraft:</span>
                <select id="enemyAircraftSelect">
                    <option value="Me-109" selected>Messerschmitt Bf 109</option>
                    <option value="Spitfire">Supermarine Spitfire</option>
                    <option value="P-51">P-51D Mustang</option>
                    <option value="P-47">P-47D Thunderbolt</option>
                    <option value="Hurricane">Hawker Hurricane</option>
                    <option value="P-40">P-40 Warhawk</option>
                    <option value="Fw-190">Focke-Wulf Fw 190</option>
                    <option value="Me-262">Me 262 Jet</option>
                    <option value="Zero">A6M Zero</option>
                </select>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn btn-primary" onclick="startCustomBattle()">START BATTLE</button>
                <button class="btn" onclick="hideSplashScreen(); document.getElementById('aircraftSelector').style.display='none';">BACK</button>
            </div>
        </div>

        <!-- Hot-seat Player Switch Screen (Enhancement #14) -->
        <div id="playerSwitchScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; z-index: 2000; justify-content: center; align-items: center; flex-direction: column;">
            <div style="text-align: center; color: #fff;">
                <h1 style="font-size: 48px; color: #e94560; margin-bottom: 30px;" id="playerSwitchTitle">PASS DEVICE TO PLAYER 2</h1>
                <p style="font-size: 24px; margin-bottom: 20px;">Player 1's orders are locked in.</p>
                <p style="font-size: 18px; color: #aaa; margin-bottom: 40px;">Click the button when ready to continue.</p>
                <button class="btn btn-primary" style="font-size: 24px; padding: 20px 40px;" onclick="completePlayerSwitch()">READY</button>
            </div>
        </div>
    </div>

    <script>
        /*
         * SOUND EFFECTS - Add these files to your project:
         *
         * Free sources found:
         * - Spitfire MG sounds: https://www.zapsplat.com (search "machine gun"), https://pixabay.com/sound-effects/
         * - Me-109 Autocannon: https://pixabay.com/sound-effects/autocannon-20mm-143113/, https://audio.com/decibelphantomx/audio/20mm-autocannon-sound
         * - Aircraft flyby/whoosh: https://pixabay.com/sound-effects/search/fly%20by/, https://www.zapsplat.com/sound-effect-category/airplanes/
         * - WW2 Engine ambient: https://www.zapsplat.com/music/aircraft-ww2-spitfire-flying-low-overhead/, https://pixabay.com/sound-effects/search/ww2/
         *
         * SVG Aircraft (replace renderSVG with actual SVG paths):
         * - Spitfire: https://freesvg.org/supermarine-spitfire-plane-vector-illustration, https://www.vecteezy.com/free-vector/spitfire
         * - Me-109: Check Etsy for paid SVG or convert free PDF plans from https://outerzone.co.uk/plan_details.asp?ID=11066
         */

        // Sound effects
        const soundSpitfireMG = new Audio('sounds/LMG.mp3');
        const soundHMG = new Audio('sounds/HMG.mp3');
        const soundMe109Cannon = new Audio('sounds/AC.mp3');
        const soundSpitfireEngine = new Audio('sounds/SPITFIRE.mp3');
        const soundMe109Engine = new Audio('sounds/BF109.mp3');

        // Configure engine sounds to loop
        soundSpitfireEngine.loop = true;
        soundMe109Engine.loop = true;
        soundSpitfireEngine.volume = 0.3; // Keep engine sounds subtle
        soundMe109Engine.volume = 0.3;

        // Configure weapon sounds
        soundSpitfireMG.volume = 0.6;
        soundMe109Cannon.volume = 0.7;

        // Game constants
        const CANVAS_WIDTH = 1800;
        const CANVAS_HEIGHT = 1000;
        let executionTime = 4000; // milliseconds - can be changed by player (2s, 4s, 6s, 8s)
        let turnTime = 4; // seconds - matches executionTime / 1000
        const ALTITUDE_MIN = 0;
        const ALTITUDE_MAX = 3000; // meters
        const MOUNTAIN_HEIGHT = 1000; // meters

        // Game state
        let gameState = 'ORDER'; // ORDER, EXECUTION, REVIEW, GAMEOVER, PAUSED
        let currentTurn = 1;
        let selectedAircraft = null;
        let ghostAircraft = null;
        let aiPredictedGhost = null; // Predicted AI position based on last turn
        let realisticMode = false; // Toggle for realistic AI display
        let executionStartTime = 0;
        let executionRecording = [];
        let isPaused = false;
        let pausedTime = 0;

        // Hot-seat multiplayer (Enhancement #14)
        let hotSeatMode = false;
        let currentPlayer = 1; // 1 or 2
        let player1Aircraft = [];
        let player2Aircraft = [];
        let awaitingPlayerSwitch = false;

        // Game settings
        let gameSettings = {
            gameMode: 'arcade', // arcade, realistic, simulation
            difficulty: 'normal', // easy, normal, hard, ace
            weather: 'clear', // clear, wind, rain, storm
            volume: 0.7,
            enableFuel: false,
            enableComponentDamage: true,
            enableWeatherEffects: true
        };

        // Campaign state
        let campaignState = {
            currentMission: 0,
            missionsCompleted: 0,
            totalKills: 0,
            pilotExperience: 0,
            pilotFatigue: 0,
            availableAircraft: ['Spitfire', 'Me-109'],
            damagedAircraft: {},
            score: 0
        };

        // Mission system (Medium Task: Enhanced with 10 missions)
        let currentMission = null;
        const missions = [
            {
                id: 1,
                name: "First Blood",
                type: "dogfight",
                description: "Your first combat sortie. Engage and destroy a single enemy fighter over the channel.",
                objectives: ["Destroy enemy aircraft"],
                playerAircraft: "Spitfire",
                enemyAircraft: ["Me-109"],
                weather: "clear",
                timeOfDay: "noon",
                briefing: "Intelligence reports a lone Me-109 on patrol. This is your chance to prove yourself. Engage and destroy the enemy fighter. Remember your training - energy management is key."
            },
            {
                id: 2,
                name: "Baptism of Fire",
                type: "dogfight",
                description: "Two enemy fighters detected. You're outnumbered but not outmatched.",
                objectives: ["Destroy both enemy aircraft", "Survive"],
                playerAircraft: "Spitfire",
                enemyAircraft: ["Me-109", "Me-109"],
                weather: "wind",
                timeOfDay: "morning",
                briefing: "Two Me-109s have been spotted heading for our coast. You must intercept and destroy them both. Watch your six and manage your ammunition carefully."
            },
            {
                id: 3,
                name: "Furball",
                type: "dogfight",
                description: "2v2 dogfight with wingman support.",
                objectives: ["Destroy enemy fighters", "Keep your wingman alive"],
                playerAircraft: "Spitfire",
                playerWingmen: ["Spitfire"],
                enemyAircraft: ["Me-109", "Fw-190"],
                weather: "clear",
                timeOfDay: "noon",
                briefing: "You'll fly with a wingman today. Two enemy fighters approach - a Me-109 and the deadly Fw-190. Use wingman commands (keys 1-4) to coordinate your attack."
            },
            {
                id: 4,
                name: "The Jug's Debut",
                type: "ground_attack",
                description: "Your first mission in the P-47 Thunderbolt. Destroy enemy ground forces.",
                objectives: ["Destroy 4 ground targets", "Survive AA fire"],
                playerAircraft: "P-47",
                enemyAircraft: [],
                groundTargets: 4,
                weather: "clear",
                timeOfDay: "afternoon",
                briefing: "You've been assigned a P-47 Thunderbolt for this ground attack mission. Target enemy supply trucks and fuel depots. Be warned - they have AA guns defending the area. Stay above 300m when possible."
            },
            {
                id: 5,
                name: "Escort Duty",
                type: "escort",
                description: "Protect friendly bombers from enemy interceptors.",
                objectives: ["Protect bombers", "Destroy enemy fighters"],
                playerAircraft: "P-51",
                enemyAircraft: ["Me-109", "Fw-190"],
                weather: "wind",
                timeOfDay: "morning",
                briefing: "Our bombers need escort deep into enemy territory. You'll fly the long-range P-51 Mustang. Two enemy fighters will try to intercept. Your priority is bomber protection - don't chase enemies too far."
            },
            {
                id: 6,
                name: "Hurricane Force",
                type: "dogfight",
                description: "Fly the Hurricane in a close-quarters dogfight.",
                objectives: ["Destroy 2 enemy aircraft"],
                playerAircraft: "Hurricane",
                enemyAircraft: ["Me-109", "Me-109"],
                weather: "rain",
                timeOfDay: "evening",
                briefing: "Rain reduces visibility and weapon accuracy. You'll fly a Hurricane - less speed than the Spitfire but armed with 4√ó 20mm cannons. Make every shot count in these weather conditions."
            },
            {
                id: 7,
                name: "The Zero Threat",
                type: "dogfight",
                description: "Face the legendary Japanese Zero fighter.",
                objectives: ["Destroy the Zero", "Do not engage in turning fight"],
                playerAircraft: "P-40",
                enemyAircraft: ["Zero"],
                weather: "clear",
                timeOfDay: "dawn",
                briefing: "A Zero has been spotted. Never try to turn-fight a Zero - it will out-turn anything we have. Use boom-and-zoom tactics: dive on it, fire, and climb away. Speed is your advantage."
            },
            {
                id: 8,
                name: "Butcher Bird",
                type: "dogfight",
                description: "Duel with the formidable Fw-190.",
                objectives: ["Destroy the Fw-190"],
                playerAircraft: "Spitfire",
                enemyAircraft: ["Fw-190"],
                weather: "storm",
                timeOfDay: "afternoon",
                briefing: "The Fw-190 'Butcher Bird' is faster and climbs better than your Spitfire. Storm conditions will affect both aircraft. Use your superior turn rate and keep the fight slow."
            },
            {
                id: 9,
                name: "Bridge Busters",
                type: "ground_attack",
                description: "Destroy a strategic bridge while under fire.",
                objectives: ["Destroy the bridge", "Survive AA fire"],
                playerAircraft: "P-47",
                enemyAircraft: [],
                groundTargets: 1,
                groundTargetTypes: ["bridge"],
                weather: "wind",
                timeOfDay: "morning",
                briefing: "Enemy supplies cross this bridge. Destroy it. Heavy AA defenses surround the target. You'll need multiple strafing runs. The bridge is tough - expect to use most of your ammunition."
            },
            {
                id: 10,
                name: "Jet Age",
                type: "dogfight",
                description: "Face the revolutionary Me-262 jet fighter.",
                objectives: ["Destroy the Me-262", "Survive"],
                playerAircraft: "P-51",
                enemyAircraft: ["Me-262"],
                weather: "clear",
                timeOfDay: "noon",
                briefing: "Intelligence reports an Me-262 jet fighter in the area. It's much faster than any propeller aircraft. Attack during turns when it's slow, or catch it landing. Head-on attacks are suicide - those 30mm cannons will tear you apart."
            }
        ];

        // Aircraft database with historically accurate specifications
        const aircraftDatabase = {
            'Spitfire': {
                name: 'Supermarine Spitfire Mk Vb',
                nation: 'British',
                role: 'Fighter',
                maxSpeed: 170, // m/s (~605 km/h)
                minSpeed: 30,
                maxTurnRate: 72, // degrees per turn
                maxClimbRate: 15,
                maxDiveRate: 30,
                maxGForce: 7,
                maxAcceleration: 15,
                maxBraking: 20,
                // Mixed armament: 4√ó .303 Browning MGs + 2√ó 20mm Hispano cannons
                weapons: [
                    {
                        type: 'mg',
                        name: '.303 Browning',
                        count: 4,
                        ammo: 1400, // 350 rounds per gun
                        burstSize: 4,
                        damage: [2, 4],
                        rof: 1,
                        sound: 'mg'
                    },
                    {
                        type: 'cannon',
                        name: '20mm Hispano Mk II',
                        count: 2,
                        ammo: 120, // 60 rounds per gun
                        burstSize: 2,
                        damage: [6, 12],
                        rof: 3,
                        sound: 'cannon'
                    }
                ],
                fuelCapacity: 386, // liters
                fuelConsumption: 0.5, // liters per second at cruise
                color: '#0099ff'
            },
            'Me-109': {
                name: 'Messerschmitt Bf 109 G-6',
                nation: 'German',
                role: 'Fighter',
                maxSpeed: 175,
                minSpeed: 30,
                maxTurnRate: 64,
                maxClimbRate: 17,
                maxDiveRate: 35,
                maxGForce: 6.5,
                maxAcceleration: 17,
                maxBraking: 18,
                // Mixed armament: 2√ó 13mm MG 131 + 1√ó 20mm MG 151/20 cannon
                weapons: [
                    {
                        type: 'hmg',
                        name: '13mm MG 131',
                        count: 2,
                        ammo: 600, // 300 rounds per gun
                        burstSize: 4, // 2 rounds per gun
                        damage: [3, 6],
                        rof: 2, // Faster than cannon
                        sound: 'hmg'
                    },
                    {
                        type: 'cannon',
                        name: '20mm MG 151/20',
                        count: 1,
                        ammo: 200, // Limited cannon ammo
                        burstSize: 2,
                        damage: [8, 15], // High damage
                        rof: 4, // Slower rate of fire
                        sound: 'cannon'
                    }
                ],
                fuelCapacity: 400,
                fuelConsumption: 0.55,
                color: '#ff4444'
            },
            'P-51': {
                name: 'North American P-51D Mustang',
                nation: 'American',
                role: 'Fighter/Escort',
                maxSpeed: 180, // m/s (~650 km/h)
                minSpeed: 28,
                maxTurnRate: 68,
                maxClimbRate: 16,
                maxDiveRate: 40,
                maxGForce: 7.5,
                maxAcceleration: 16,
                maxBraking: 19,
                weapons: { type: 'hmg', count: 6, ammo: 1880, burstSize: 6, damage: [3, 6], rof: 2 },
                fuelCapacity: 730, // Excellent range
                fuelConsumption: 0.45,
                color: '#00aaff'
            },
            'P-47': {
                name: 'Republic P-47D Thunderbolt',
                nation: 'American',
                role: 'Fighter-Bomber',
                maxSpeed: 173,
                minSpeed: 32,
                maxTurnRate: 58, // Heavy, less maneuverable
                maxClimbRate: 14,
                maxDiveRate: 45, // Excellent dive performance
                maxGForce: 7,
                maxAcceleration: 14,
                maxBraking: 16,
                weapons: { type: 'hmg', count: 8, ammo: 3400, burstSize: 8, damage: [3, 6], rof: 1 },
                fuelCapacity: 1155, // Very long range
                fuelConsumption: 0.6,
                canCarryBombs: true,
                canCarryRockets: true,
                color: '#0077cc'
            },
            'Hurricane': {
                name: 'Hawker Hurricane Mk IIB',
                nation: 'British',
                role: 'Fighter',
                maxSpeed: 165,
                minSpeed: 31,
                maxTurnRate: 70,
                maxClimbRate: 13,
                maxDiveRate: 28,
                maxGForce: 6.5,
                maxAcceleration: 14,
                maxBraking: 18,
                // Mixed armament: 4√ó .303 Browning MGs + 2√ó 20mm Hispano cannons
                weapons: [
                    {
                        type: 'mg',
                        name: '.303 Browning',
                        count: 4,
                        ammo: 1336, // 334 rounds per gun
                        burstSize: 4,
                        damage: [2, 4],
                        rof: 1,
                        sound: 'mg'
                    },
                    {
                        type: 'cannon',
                        name: '20mm Hispano Mk II',
                        count: 2,
                        ammo: 120, // 60 rounds per gun
                        burstSize: 2,
                        damage: [6, 12],
                        rof: 3,
                        sound: 'cannon'
                    }
                ],
                fuelCapacity: 386,
                fuelConsumption: 0.5,
                color: '#0088dd'
            },
            'P-40': {
                name: 'Curtiss P-40 Warhawk',
                nation: 'American',
                role: 'Fighter',
                maxSpeed: 168,
                minSpeed: 30,
                maxTurnRate: 66,
                maxClimbRate: 12, // Poor climb rate
                maxDiveRate: 38, // Good dive
                maxGForce: 7,
                maxAcceleration: 14,
                maxBraking: 17,
                weapons: { type: 'hmg', count: 6, ammo: 1740, burstSize: 6, damage: [3, 6], rof: 2 },
                fuelCapacity: 568,
                fuelConsumption: 0.52,
                color: '#00aa88'
            },
            'Fw-190': {
                name: 'Focke-Wulf Fw 190 A-8',
                nation: 'German',
                role: 'Fighter',
                maxSpeed: 178,
                minSpeed: 32,
                maxTurnRate: 62,
                maxClimbRate: 18, // Excellent climb
                maxDiveRate: 42, // Excellent dive
                maxGForce: 7.5,
                maxAcceleration: 18,
                maxBraking: 17,
                // Mixed armament: 2√ó 13mm MG 131 + 2√ó 20mm MG 151/20
                weapons: [
                    {
                        type: 'hmg',
                        name: '13mm MG 131',
                        count: 2,
                        ammo: 950, // 475 rounds per gun
                        burstSize: 4, // 2 rounds per gun
                        damage: [3, 6],
                        rof: 2,
                        sound: 'hmg'
                    },
                    {
                        type: 'cannon',
                        name: '20mm MG 151/20',
                        count: 2,
                        ammo: 500, // 250 rounds per gun
                        burstSize: 4, // 2 rounds per gun
                        damage: [7, 14],
                        rof: 3,
                        sound: 'cannon'
                    }
                ],
                fuelCapacity: 525,
                fuelConsumption: 0.58,
                color: '#ff3333'
            },
            'Me-262': {
                name: 'Messerschmitt Me 262 Schwalbe',
                nation: 'German',
                role: 'Jet Fighter',
                maxSpeed: 240, // m/s (~870 km/h) - MUCH faster!
                minSpeed: 50, // Jets have higher stall speeds
                maxTurnRate: 48, // Poor turn rate
                maxClimbRate: 20,
                maxDiveRate: 50,
                maxGForce: 6,
                maxAcceleration: 25, // Excellent acceleration
                maxBraking: 12, // Poor deceleration
                weapons: { type: 'cannon', count: 4, ammo: 360, burstSize: 4, damage: [8, 16], rof: 3 },
                fuelCapacity: 2570, // High fuel consumption
                fuelConsumption: 2.5, // Jets burn fuel fast!
                isJet: true,
                color: '#cc0000'
            },
            'Zero': {
                name: 'Mitsubishi A6M5 Zero',
                nation: 'Japanese',
                role: 'Fighter',
                maxSpeed: 166,
                minSpeed: 26, // Excellent slow-speed handling
                maxTurnRate: 80, // BEST turn rate!
                maxClimbRate: 14,
                maxDiveRate: 25, // Weak structure, poor dive
                maxGForce: 6, // Fragile airframe
                maxAcceleration: 13,
                maxBraking: 16,
                // Mixed armament: 2√ó 7.7mm Type 97 MGs + 2√ó 20mm Type 99 cannons
                weapons: [
                    {
                        type: 'mg',
                        name: '7.7mm Type 97',
                        count: 2,
                        ammo: 1400, // 700 rounds per gun
                        burstSize: 4, // 2 rounds per gun
                        damage: [2, 3],
                        rof: 1,
                        sound: 'mg'
                    },
                    {
                        type: 'cannon',
                        name: '20mm Type 99',
                        count: 2,
                        ammo: 200, // 100 rounds per gun - limited!
                        burstSize: 2,
                        damage: [5, 11],
                        rof: 3,
                        sound: 'cannon'
                    }
                ],
                fuelCapacity: 518,
                fuelConsumption: 0.35, // Very fuel efficient
                lowDurability: true, // Takes extra damage
                color: '#ff6666'
            }
        };

        // Weather effects
        let weatherState = {
            windSpeed: 0,
            windDirection: 0,
            rainfall: 0,
            visibility: 1.0
        };

        // Enhancement #3: Wingman/Squadron Mechanics
        const formations = {
            'finger_four': [
                { x: 0, y: 0 },      // Lead
                { x: 50, y: -50 },   // Right wing
                { x: -50, y: -50 },  // Left wing
                { x: 50, y: -100 }   // Tail end charlie
            ],
            'vic': [
                { x: 0, y: 0 },      // Lead
                { x: 60, y: -40 },   // Right
                { x: -60, y: -40 }   // Left
            ],
            'line_abreast': [
                { x: -80, y: 0 },    // Left
                { x: 0, y: 0 },      // Center
                { x: 80, y: 0 }      // Right
            ],
            'echelon_right': [
                { x: 0, y: 0 },
                { x: 50, y: -50 },
                { x: 100, y: -100 }
            ],
            'echelon_left': [
                { x: 0, y: 0 },
                { x: -50, y: -50 },
                { x: -100, y: -100 }
            ]
        };

        let squadron = {
            formation: 'finger_four',
            leader: null,
            wingmen: [],
            inFormation: false,
            formationBonus: 0
        };

        let wingmanCommands = {
            'ATTACK_MY_TARGET': 'attack_my_target',
            'COVER_ME': 'cover_me',
            'BREAK_ATTACK': 'break_attack',
            'REJOIN': 'rejoin',
            'FREE_HUNT': 'free_hunt'
        };

        let activeWingmanCommand = null;

        // Ground targets (Enhancement #6)
        class GroundTarget {
            constructor(x, y, type = 'truck') {
                this.x = x;
                this.y = y;
                this.type = type; // truck, aa_gun, fuel_depot, bridge
                this.health = 100;
                this.isDestroyed = false;
                this.size = type === 'bridge' ? 60 : type === 'fuel_depot' ? 40 : 20;

                // AA gun specific properties (Quick Win #3)
                this.isAAGun = type === 'aa_gun';
                this.fireCooldown = 0;
                this.rateOfFire = 20; // Frames between shots
                this.range = 600; // meters
                this.accuracy = 0.15; // 15% hit chance at optimal range
                this.flakEffects = []; // Visual flak bursts
            }

            render() {
                // Render flak bursts (Quick Win #3)
                const now = Date.now();
                this.flakEffects = this.flakEffects.filter(flak => now - flak.time < flak.duration);
                for (let flak of this.flakEffects) {
                    const age = now - flak.time;
                    const progress = age / flak.duration;
                    const alpha = 1 - progress;

                    // Black smoke puff
                    ctx.fillStyle = `rgba(40, 40, 40, ${alpha * 0.6})`;
                    const size = 15 + progress * 20;
                    ctx.beginPath();
                    ctx.arc(flak.x, flak.y, size, 0, Math.PI * 2);
                    ctx.fill();

                    // Orange flash at start
                    if (progress < 0.2) {
                        ctx.fillStyle = `rgba(255, 150, 0, ${(1 - progress / 0.2) * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(flak.x, flak.y, size * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                if (this.isDestroyed) {
                    // Render destroyed target
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.6)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 0.8, 0, Math.PI * 2);
                    ctx.fill();

                    // Smoke
                    for (let i = 0; i < 3; i++) {
                        ctx.fillStyle = `rgba(40, 40, 40, ${0.4 - i * 0.1})`;
                        ctx.beginPath();
                        ctx.arc(this.x + (Math.random() - 0.5) * 10, this.y - 10 - i * 8, 6 + i * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Render active target based on type
                    if (this.type === 'truck') {
                        ctx.fillStyle = '#886644';
                        ctx.fillRect(this.x - 10, this.y - 6, 20, 12);
                        ctx.fillRect(this.x - 6, this.y - 10, 8, 8);
                    } else if (this.type === 'aa_gun') {
                        ctx.fillStyle = '#555555';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#333333';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.x, this.y - 15);
                        ctx.stroke();
                    } else if (this.type === 'fuel_depot') {
                        ctx.fillStyle = '#aa8844';
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.arc(this.x - 20 + i * 20, this.y, 15, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else if (this.type === 'bridge') {
                        ctx.fillStyle = '#998877';
                        ctx.fillRect(this.x - 30, this.y - 8, 60, 16);
                        ctx.fillStyle = '#667755';
                        for (let i = 0; i < 4; i++) {
                            ctx.fillRect(this.x - 25 + i * 17, this.y - 12, 8, 24);
                        }
                    }

                    // Health bar
                    if (this.health < 100) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                        ctx.fillRect(this.x - 15, this.y - this.size - 10, 30 * (this.health / 100), 4);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.strokeRect(this.x - 15, this.y - this.size - 10, 30, 4);
                    }
                }
            }

            takeDamage(amount) {
                if (this.isDestroyed) return false;
                this.health -= amount;
                if (this.health <= 0) {
                    this.isDestroyed = true;
                    return true;
                }
                return false;
            }

            // Quick Win #3: AA Gun fire-back
            fireAtAircraft(aircraft) {
                if (!this.isAAGun || this.isDestroyed) return null;
                if (this.fireCooldown > 0) {
                    this.fireCooldown--;
                    return null;
                }

                // Find closest aircraft in range
                let target = null;
                let minDist = Infinity;

                for (let plane of aircraft) {
                    if (plane.isDestroyed) continue;

                    const dx = plane.x - this.x;
                    const dy = plane.y - this.y;
                    const distance2D = Math.sqrt(dx * dx + dy * dy);
                    const distance3D = Math.sqrt(distance2D * distance2D + plane.altitude * plane.altitude);

                    if (distance3D < this.range && distance3D < minDist) {
                        minDist = distance3D;
                        target = plane;
                    }
                }

                if (!target) return null;

                // Fire!
                this.fireCooldown = this.rateOfFire;

                // Calculate hit chance (decreases with altitude and distance)
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const distance2D = Math.sqrt(dx * dx + dy * dy);

                let hitChance = this.accuracy;
                hitChance *= Math.max(0.1, 1 - distance2D / this.range); // Distance factor
                hitChance *= Math.max(0.2, 1 - target.altitude / 1000); // Altitude factor (harder to hit high aircraft)
                hitChance *= Math.max(0.5, 1 - target.speed / target.maxSpeed); // Speed factor (harder to hit fast aircraft)

                // Create flak burst visual
                const flakX = target.x + (Math.random() - 0.5) * 50;
                const flakY = target.y + (Math.random() - 0.5) * 50;
                this.flakEffects.push({
                    x: flakX,
                    y: flakY,
                    altitude: target.altitude,
                    time: Date.now(),
                    duration: 800
                });

                // Check if hit
                if (Math.random() < hitChance) {
                    const damage = 15 + Math.random() * 15; // 15-30 damage
                    applyComponentDamage(target, damage);
                    console.log(`AA Gun HIT ${target.name}! Damage: ${damage.toFixed(1)}, Distance: ${distance2D.toFixed(0)}m, Alt: ${target.altitude.toFixed(0)}m`);
                    return { hit: true, target: target, damage: damage };
                } else {
                    return { hit: false, target: target };
                }
            }
        }

        let groundTargets = [];

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Load aircraft SVG images
        const aircraftImages = {
            spitfire: new Image(),
            bf109: new Image()
        };
        let imagesLoaded = 0;
        const totalImages = 2;

        aircraftImages.spitfire.onload = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                console.log('All aircraft images loaded');
            }
        };
        aircraftImages.bf109.onload = () => {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                console.log('All aircraft images loaded');
            }
        };

        // Try to load SVG files, will fallback to shapes if not found
        aircraftImages.spitfire.src = 'spitfire.svg';
        aircraftImages.bf109.src = 'bf109.svg';

        // Terrain generation
        class Terrain {
            constructor() {
                this.mountains = [];
                this.clouds = [];
                this.generateMountains();
                this.generateClouds();
            }

            // Fractal subdivision helper - adds naturalistic detail to mountain edges
            subdivideLine(p1, p2, depth, roughness) {
                if (depth === 0) {
                    return [p2];
                }

                // Calculate midpoint with random displacement perpendicular to line
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;

                // Direction perpendicular to the line
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const perpX = -dy / length;
                const perpY = dx / length;

                // Random displacement (decreases with depth for natural fractal look)
                const displacement = (Math.random() - 0.5) * roughness * Math.pow(0.5, depth);

                const mid = {
                    x: midX + perpX * displacement,
                    y: midY + perpY * displacement
                };

                // Recursively subdivide both segments
                const left = this.subdivideLine(p1, mid, depth - 1, roughness);
                const right = this.subdivideLine(mid, p2, depth - 1, roughness);

                return [mid, ...left, ...right];
            }

            generateMountains() {
                // Generate realistic mountain ranges with fractal edges
                for (let i = 0; i < 8; i++) {
                    const baseX = Math.random() * CANVAS_WIDTH;
                    const baseY = Math.random() * CANVAS_HEIGHT;
                    const baseHeight = 400 + Math.random() * 600;

                    // Create a cluster of peaks for each mountain
                    for (let j = 0; j < 3; j++) {
                        // Generate initial rough polygon
                        const numPeaks = 4 + Math.floor(Math.random() * 3); // 4-6 initial vertices
                        const baseVertices = [];
                        const centerX = baseX + (Math.random() - 0.5) * 150;
                        const centerY = baseY + (Math.random() - 0.5) * 150;
                        const baseRadius = 40 + Math.random() * 60;

                        for (let v = 0; v < numPeaks; v++) {
                            const angle = (v / numPeaks) * Math.PI * 2;
                            // Vary the radius for each vertex to create base jagged shape
                            const radiusVariation = 0.5 + Math.random() * 0.8; // 50% to 130% of base
                            const vx = centerX + Math.cos(angle) * baseRadius * radiusVariation;
                            const vy = centerY + Math.sin(angle) * baseRadius * radiusVariation;
                            baseVertices.push({ x: vx, y: vy });
                        }

                        // Apply fractal subdivision to each edge for natural jagged peaks
                        const fractalVertices = [];
                        const roughness = baseRadius * 0.8; // Controls how jagged the edges are
                        const subdivisionDepth = 2; // 2-3 levels of subdivision for detail

                        for (let v = 0; v < baseVertices.length; v++) {
                            const p1 = baseVertices[v];
                            const p2 = baseVertices[(v + 1) % baseVertices.length];

                            fractalVertices.push(p1);
                            // Add subdivided points between p1 and p2
                            const subdivided = this.subdivideLine(p1, p2, subdivisionDepth, roughness);
                            // Remove the last point (p2) as it will be added in next iteration
                            fractalVertices.push(...subdivided.slice(0, -1));
                        }

                        this.mountains.push({
                            x: centerX,
                            y: centerY,
                            radius: baseRadius, // Keep for height calculations
                            vertices: fractalVertices,
                            height: baseHeight * (0.7 + Math.random() * 0.6),
                            peakOffset: Math.random() * 20 - 10
                        });
                    }
                }
            }

            generateClouds() {
                // Generate cloud layers at various altitudes - viewed from above
                for (let i = 0; i < 10; i++) {
                    const centerX = Math.random() * CANVAS_WIDTH;
                    const centerY = Math.random() * CANVAS_HEIGHT;
                    const baseRadius = 60 + Math.random() * 100;

                    // Create fluffy cloud shape with multiple lobes (like cumulus clouds from above)
                    const numLobes = 4 + Math.floor(Math.random() * 5); // 4-8 lobes
                    const lobes = [];

                    for (let l = 0; l < numLobes; l++) {
                        const angle = (l / numLobes) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
                        const distance = baseRadius * (0.3 + Math.random() * 0.5); // Lobes extend 30-80% from center
                        const lobeSize = baseRadius * (0.4 + Math.random() * 0.4); // Lobe size varies

                        lobes.push({
                            x: centerX + Math.cos(angle) * distance,
                            y: centerY + Math.sin(angle) * distance,
                            radius: lobeSize
                        });
                    }

                    this.clouds.push({
                        x: centerX,
                        y: centerY,
                        radius: baseRadius,
                        lobes: lobes,
                        altitude: 300 + Math.random() * 1500, // Clouds at 300-1800m
                        thickness: 100 + Math.random() * 200, // Vertical thickness
                        opacity: 0.3 + Math.random() * 0.4
                    });
                }
            }

            getHeightAt(x, y) {
                let maxHeight = 0;
                for (let mountain of this.mountains) {
                    const dx = x - mountain.x;
                    const dy = y - mountain.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < mountain.radius) {
                        const heightAtPoint = mountain.height * (1 - dist / mountain.radius);
                        maxHeight = Math.max(maxHeight, heightAtPoint);
                    }
                }
                return maxHeight;
            }

            // Check if line of sight is blocked by clouds
            isLineOfSightClear(x1, y1, alt1, x2, y2, alt2) {
                // Sample points along the line
                const samples = 10;
                for (let i = 0; i <= samples; i++) {
                    const t = i / samples;
                    const x = x1 + (x2 - x1) * t;
                    const y = y1 + (y2 - y1) * t;
                    const alt = alt1 + (alt2 - alt1) * t;

                    // Check if this point is inside any cloud
                    for (let cloud of this.clouds) {
                        const dx = x - cloud.x;
                        const dy = y - cloud.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < cloud.radius) {
                            // Check altitude overlap
                            const cloudBottom = cloud.altitude - cloud.thickness / 2;
                            const cloudTop = cloud.altitude + cloud.thickness / 2;
                            if (alt >= cloudBottom && alt <= cloudTop) {
                                return false; // Line of sight blocked
                            }
                        }
                    }
                }
                return true; // Clear line of sight
            }

            render() {
                // Render mountains with jagged, polyhedrous peaks
                for (let mountain of this.mountains) {
                    const intensity = mountain.height / MOUNTAIN_HEIGHT;

                    // Draw jagged mountain polygon
                    ctx.save();

                    // Create clipping region for gradient
                    ctx.beginPath();
                    if (mountain.vertices && mountain.vertices.length > 0) {
                        ctx.moveTo(mountain.vertices[0].x, mountain.vertices[0].y);
                        for (let i = 1; i < mountain.vertices.length; i++) {
                            ctx.lineTo(mountain.vertices[i].x, mountain.vertices[i].y);
                        }
                        ctx.closePath();
                    }
                    ctx.clip();

                    // Mountain body with gradient from peak
                    const gradient = ctx.createRadialGradient(
                        mountain.x + mountain.peakOffset, mountain.y, 0,
                        mountain.x, mountain.y, mountain.radius * 1.5
                    );

                    // Snow-capped peaks for high mountains
                    if (mountain.height > 700) {
                        gradient.addColorStop(0, `rgba(200, 200, 210, ${intensity * 0.8})`); // Snowy peak
                        gradient.addColorStop(0.3, `rgba(120, 110, 100, ${intensity * 0.7})`); // Rocky middle
                        gradient.addColorStop(0.7, `rgba(80, 70, 60, ${intensity * 0.5})`); // Dark base
                    } else {
                        gradient.addColorStop(0, `rgba(100, 95, 80, ${intensity * 0.7})`); // Peak
                        gradient.addColorStop(0.5, `rgba(70, 65, 55, ${intensity * 0.6})`); // Middle
                        gradient.addColorStop(0.8, `rgba(50, 45, 40, ${intensity * 0.4})`); // Base
                    }
                    gradient.addColorStop(1, 'rgba(30, 30, 25, 0)');

                    ctx.fillStyle = gradient;
                    ctx.fillRect(mountain.x - mountain.radius * 2, mountain.y - mountain.radius * 2,
                                 mountain.radius * 4, mountain.radius * 4);

                    ctx.restore();

                    // Draw jagged outline
                    ctx.strokeStyle = `rgba(40, 35, 30, ${intensity * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    if (mountain.vertices && mountain.vertices.length > 0) {
                        ctx.moveTo(mountain.vertices[0].x, mountain.vertices[0].y);
                        for (let i = 1; i < mountain.vertices.length; i++) {
                            ctx.lineTo(mountain.vertices[i].x, mountain.vertices[i].y);
                        }
                        ctx.closePath();
                    }
                    ctx.stroke();

                    // Add some shading triangles for depth
                    ctx.fillStyle = `rgba(20, 20, 15, ${intensity * 0.3})`;
                    for (let i = 0; i < mountain.vertices.length; i += 2) {
                        const v1 = mountain.vertices[i];
                        const v2 = mountain.vertices[(i + 1) % mountain.vertices.length];
                        ctx.beginPath();
                        ctx.moveTo(mountain.x, mountain.y);
                        ctx.lineTo(v1.x, v1.y);
                        ctx.lineTo(v2.x, v2.y);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Render clouds as fluffy organic shapes (viewed from above)
                for (let cloud of this.clouds) {
                    // Draw each lobe of the cloud
                    for (let lobe of cloud.lobes) {
                        const gradient = ctx.createRadialGradient(
                            lobe.x, lobe.y, 0,
                            lobe.x, lobe.y, lobe.radius
                        );
                        gradient.addColorStop(0, `rgba(255, 255, 255, ${cloud.opacity * 0.9})`);
                        gradient.addColorStop(0.5, `rgba(240, 245, 250, ${cloud.opacity * 0.6})`);
                        gradient.addColorStop(1, 'rgba(220, 230, 245, 0)');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(lobe.x, lobe.y, lobe.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Add central mass for better cohesion
                    const centerGradient = ctx.createRadialGradient(
                        cloud.x, cloud.y, 0,
                        cloud.x, cloud.y, cloud.radius * 0.5
                    );
                    centerGradient.addColorStop(0, `rgba(255, 255, 255, ${cloud.opacity})`);
                    centerGradient.addColorStop(0.7, `rgba(245, 248, 252, ${cloud.opacity * 0.5})`);
                    centerGradient.addColorStop(1, 'rgba(230, 235, 245, 0)');

                    ctx.fillStyle = centerGradient;
                    ctx.beginPath();
                    ctx.arc(cloud.x, cloud.y, cloud.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Aircraft class
        class Aircraft {
            constructor(name, type, x, y, altitude, heading, isPlayer = false) {
                this.name = name;
                this.type = type;
                this.x = x;
                this.y = y;
                this.altitude = altitude;
                this.heading = heading; // degrees
                this.speed = 140; // m/s - start at cruise speed
                this.throttle = 0.7; // 0.0 to 1.0 (70% = cruise)
                this.isPlayer = isPlayer;
                this.hasOrders = false;
                this.targetX = x;
                this.targetY = y;
                this.targetAltitude = altitude;
                this.targetHeading = heading;
                this.targetSpeed = 140;

                // Starting positions for interpolation
                this.startX = x;
                this.startY = y;
                this.startAltitude = altitude;
                this.startHeading = heading;
                this.startSpeed = 140; // Start at cruise speed

                // Load aircraft specifications from database
                const specs = aircraftDatabase[type] || aircraftDatabase['Spitfire'];
                this.fullName = specs.name;
                this.nation = specs.nation;
                this.role = specs.role;
                this.maxSpeed = specs.maxSpeed;
                this.minSpeed = specs.minSpeed;
                this.maxTurnRate = specs.maxTurnRate;
                this.maxClimbRate = specs.maxClimbRate;
                this.maxDiveRate = specs.maxDiveRate;
                this.maxGForce = specs.maxGForce;
                this.maxAcceleration = specs.maxAcceleration;
                this.maxBraking = specs.maxBraking;
                this.aircraftColor = specs.color;
                this.isJet = specs.isJet || false;
                this.lowDurability = specs.lowDurability || false;

                // Weapons from database - support both single weapon and mixed armament
                const weaponsData = specs.weapons;
                this.hasMixedArmament = Array.isArray(weaponsData);

                if (this.hasMixedArmament) {
                    // Mixed armament (like Me-109)
                    this.weaponGroups = weaponsData.map(w => ({
                        type: w.type,
                        name: w.name,
                        count: w.count,
                        ammunition: w.ammo,
                        maxAmmunition: w.ammo,
                        ammoPerBurst: w.burstSize,
                        damageMin: w.damage[0],
                        damageMax: w.damage[1],
                        rateOfFire: w.rof,
                        firingCooldown: 0,
                        sound: w.sound
                    }));

                    // Set primary weapon type and total ammo for UI
                    this.weaponType = 'mixed';
                    this.ammunition = weaponsData.reduce((sum, w) => sum + w.ammo, 0);
                    this.maxAmmunition = this.ammunition;
                    this.fireThreshold = 0.30; // Mixed armament threshold
                } else {
                    // Single weapon type (legacy support)
                    this.weaponType = weaponsData.type;
                    this.ammunition = weaponsData.ammo;
                    this.maxAmmunition = weaponsData.ammo;
                    this.ammoPerBurst = weaponsData.burstSize;
                    this.damagePerHit = weaponsData.damage[0] + Math.random() * (weaponsData.damage[1] - weaponsData.damage[0]);
                    this.rateOfFire = weaponsData.rof;
                    this.fireThreshold = weaponsData.type === 'cannon' ? 0.35 : 0.25;
                    this.weaponGroups = null;
                }

                // Fuel system
                this.fuel = specs.fuelCapacity;
                this.maxFuel = specs.fuelCapacity;
                this.fuelConsumption = specs.fuelConsumption;

                // Bombs and rockets (if applicable)
                this.canCarryBombs = specs.canCarryBombs || false;
                this.canCarryRockets = specs.canCarryRockets || false;
                this.bombs = this.canCarryBombs ? 2 : 0;
                this.rockets = this.canCarryRockets ? 8 : 0;

                // Component damage system (Enhancement #4)
                this.damage = 0;
                this.componentDamage = {
                    engine: 0,
                    wings: 0,
                    tail: 0,
                    cockpit: 0,
                    fuelTank: 0,
                    leftWing: 0,
                    rightWing: 0
                };
                this.fuelLeak = false;
                this.asymmetricDamage = { left: 0, right: 0 }; // Wing damage affecting turn

                this.timeOnTarget = 0;
                this.pilotSkill = 0.5 + Math.random() * 0.3; // 50-80%
                this.gunnerySkill = 0.5 + Math.random() * 0.3;
                this.pilotWounded = false;
                this.isFiring = false;
                this.firingCooldown = 0;
                this.lastHitBy = null;
                this.lastHitTime = 0;
                this.isDestroyed = false;
                this.canBailout = true;
                this.pilotBailedOut = false;

                // Visual hit effects
                this.hitEffects = [];
                this.smokeParticles = [];

                // Flight path calculation
                this.flightPath = null;
                this.inStall = false;
                this.slipAngle = 0;

                // Roll mechanics
                this.rollType = 'none';
                this.isInverted = false;
                this.isRolling = false;
                this.rollProgress = 0;
                this.currentGForce = 1.0;
                this.peakGForce = 1.0;
                this.gForcePenalty = 0;

                // Advanced aerobatic maneuvers
                this.maneuverType = 'none'; // none, immelmann, split-s, loop, half-loop

                // Automatic banking visualization
                this.currentTurnRate = 0; // Current turn rate in degrees/second for visual banking

                // Gun convergence (Enhancement #8)
                this.gunConvergence = 300; // meters - distance where guns converge

                // Critical hit system
                this.criticalHitsDealt = 0; // Total critical hits dealt
                this.criticalHitsTaken = 0; // Total critical hits received
                this.systemDamage = {
                    engine: 0,    // 0-1, reduces speed and climb rate
                    controls: 0,  // 0-1, reduces turn rate
                    weapons: 0    // 0-1, reduces accuracy and fire rate
                };
            }

            getScaleForAltitude() {
                // Higher altitude = larger visual size
                const baseScale = 0.5;
                const altitudeFactor = this.altitude / 1000;
                return baseScale + altitudeFactor * 0.5;
            }

            renderSVG(isGhost = false, ghostState = 'valid') {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate((this.heading * Math.PI) / 180);

                const scale = this.getScaleForAltitude();
                ctx.scale(scale, scale);

                // Apply roll animation - simulate banking by scaling x-axis
                let rollAngle = 0; // 0 to 360 degrees
                if (this.isRolling && !isGhost) {
                    if (this.rollType === 'half') {
                        // Half roll: 0¬∞ to 180¬∞
                        rollAngle = this.rollProgress * 180;
                    } else if (this.rollType === 'full') {
                        // Full roll: 0¬∞ to 360¬∞
                        rollAngle = this.rollProgress * 360;
                    }
                } else if (this.isInverted && !isGhost) {
                    // Maintain inverted appearance (180¬∞)
                    rollAngle = 180;
                } else if (!this.isRolling && !isGhost && Math.abs(this.currentTurnRate) > 2) {
                    // Automatic visual banking during turns (not during roll maneuvers)
                    // Bank angle proportional to turn rate: max 60¬∞ bank at max turn rate
                    const maxBankAngle = 60; // degrees
                    const normalizedTurnRate = Math.min(Math.abs(this.currentTurnRate) / (this.maxTurnRate / turnTime), 1.0);
                    const bankAngle = normalizedTurnRate * maxBankAngle;
                    // Convert bank angle to roll appearance (bank left/right shows as narrower)
                    rollAngle = bankAngle;
                }

                // Convert roll angle to x-axis scale for top-down view
                // 0¬∞ = scale 1.0 (wings full width), 90¬∞ = scale 0.1 (edge-on), 180¬∞ = scale 1.0 (inverted)
                const rollRad = (rollAngle * Math.PI) / 180;
                const xScale = Math.abs(Math.cos(rollRad)) * 0.9 + 0.1; // Range from 0.1 to 1.0
                ctx.scale(xScale, 1.0);

                // Set color based on state
                if (this.isDestroyed && !isGhost) {
                    // Destroyed aircraft - gray/black wreckage
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = '#444444';
                    ctx.strokeStyle = '#222222';
                } else if (isGhost) {
                    if (ghostState === 'illegal') {
                        ctx.globalAlpha = 0.7;
                        ctx.fillStyle = '#ff0000';
                        ctx.strokeStyle = '#ff0000';
                    } else if (ghostState === 'stressful') {
                        ctx.globalAlpha = 0.7;
                        ctx.fillStyle = '#ffff00';
                        ctx.strokeStyle = '#ffff00';
                    } else {
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = '#00ff00';
                        ctx.strokeStyle = '#00ff00';
                    }
                } else {
                    if (this.isPlayer) {
                        ctx.fillStyle = '#0099ff';
                        ctx.strokeStyle = '#0099ff';
                    } else {
                        ctx.fillStyle = '#ff4444';
                        ctx.strokeStyle = '#ff4444';
                    }
                }

                // Get the appropriate SVG image
                const img = this.type === 'Spitfire' ? aircraftImages.spitfire : aircraftImages.bf109;
                const useImage = img && img.complete && img.naturalWidth > 0;

                if (useImage) {
                    // Draw the aircraft SVG image centered
                    const imgWidth = 80;
                    const imgHeight = 80;

                    // Set composite operation for transparency
                    if (isGhost) {
                        // For ghosts, draw image then apply color overlay
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.drawImage(img, -imgWidth/2, -imgHeight/2, imgWidth, imgHeight);

                        // Apply color tint for ghost state
                        ctx.globalCompositeOperation = 'source-atop';
                        ctx.fillRect(-imgWidth/2, -imgHeight/2, imgWidth, imgHeight);
                        ctx.globalCompositeOperation = 'source-over';
                    } else {
                        // Normal drawing with full transparency support
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.drawImage(img, -imgWidth/2, -imgHeight/2, imgWidth, imgHeight);

                        // Only apply color tint if using destroyed state
                        if (this.isDestroyed) {
                            ctx.globalCompositeOperation = 'source-atop';
                            ctx.fillRect(-imgWidth/2, -imgHeight/2, imgWidth, imgHeight);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                    }
                } else {
                    // Fallback to geometric shapes if SVG not loaded
                    ctx.lineWidth = 2;

                    // Draw aircraft-specific shape (distinctive top-down silhouettes)
                    switch(this.type) {
                        case 'Spitfire':
                        // Famous elliptical wings
                        ctx.beginPath();
                        ctx.moveTo(0, -30); // Nose
                        ctx.lineTo(-4, 0); // Leading edge to wing root
                        ctx.ellipse(-15, 0, 12, 6, 0, 0, Math.PI * 2); // Port elliptical wing
                        ctx.moveTo(-4, 0);
                        ctx.lineTo(-4, 10);
                        ctx.lineTo(4, 10);
                        ctx.lineTo(4, 0); // Fuselage
                        ctx.ellipse(15, 0, 12, 6, 0, 0, Math.PI * 2); // Starboard elliptical wing
                        ctx.moveTo(4, 0);
                        ctx.lineTo(0, -30);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Tail
                        ctx.beginPath();
                        ctx.moveTo(-6, 10);
                        ctx.lineTo(-6, 14);
                        ctx.lineTo(6, 14);
                        ctx.lineTo(6, 10);
                        ctx.stroke();
                        break;

                    case 'Me-109':
                        // Angular German fighter
                        ctx.beginPath();
                        ctx.moveTo(0, -30); // Nose
                        ctx.lineTo(-5, -5); // Angled to wing
                        ctx.lineTo(-22, -2); // Wing leading edge
                        ctx.lineTo(-22, 2); // Wing trailing edge
                        ctx.lineTo(-5, 10); // Back to fuselage
                        ctx.lineTo(-5, 15); // Tail
                        ctx.lineTo(5, 15);
                        ctx.lineTo(5, 10);
                        ctx.lineTo(22, 2);
                        ctx.lineTo(22, -2);
                        ctx.lineTo(5, -5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;

                    case 'P-51':
                        // Laminar flow wings, square wingtips
                        ctx.beginPath();
                        ctx.moveTo(0, -32); // Long nose (radiator scoop)
                        ctx.lineTo(-4, -8);
                        ctx.lineTo(-24, -5); // Square wingtip
                        ctx.lineTo(-24, 3);
                        ctx.lineTo(-5, 8);
                        ctx.lineTo(-5, 12); // Tail
                        ctx.lineTo(5, 12);
                        ctx.lineTo(5, 8);
                        ctx.lineTo(24, 3);
                        ctx.lineTo(24, -5);
                        ctx.lineTo(4, -8);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;

                    case 'P-47':
                        // Big bulky "Jug"
                        ctx.beginPath();
                        ctx.moveTo(0, -28); // Blunt nose
                        ctx.lineTo(-7, -10); // Wide fuselage
                        ctx.lineTo(-26, -8); // Wide wings
                        ctx.lineTo(-26, 4);
                        ctx.lineTo(-7, 6);
                        ctx.lineTo(-7, 14); // Wide tail
                        ctx.lineTo(7, 14);
                        ctx.lineTo(7, 6);
                        ctx.lineTo(26, 4);
                        ctx.lineTo(26, -8);
                        ctx.lineTo(7, -10);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;

                    case 'Hurricane':
                        // Similar to Spitfire but less refined
                        ctx.beginPath();
                        ctx.moveTo(0, -28); // Shorter nose
                        ctx.lineTo(-5, 0);
                        ctx.lineTo(-23, 0); // Straighter wings
                        ctx.lineTo(-20, 5);
                        ctx.lineTo(-5, 8);
                        ctx.lineTo(-5, 13);
                        ctx.lineTo(5, 13);
                        ctx.lineTo(5, 8);
                        ctx.lineTo(20, 5);
                        ctx.lineTo(23, 0);
                        ctx.lineTo(5, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;

                    case 'P-40':
                        // Shark-mouth fuselage, swept-back look
                        ctx.beginPath();
                        ctx.moveTo(0, -30); // Shark nose
                        ctx.lineTo(-6, -8); // Wider fuselage for shark mouth
                        ctx.lineTo(-25, 0); // Slightly swept wings
                        ctx.lineTo(-22, 6);
                        ctx.lineTo(-6, 10);
                        ctx.lineTo(-5, 14);
                        ctx.lineTo(5, 14);
                        ctx.lineTo(6, 10);
                        ctx.lineTo(22, 6);
                        ctx.lineTo(25, 0);
                        ctx.lineTo(6, -8);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;

                    case 'Fw-190':
                        // Wide "Butcher Bird" - radial engine
                        ctx.beginPath();
                        ctx.moveTo(0, -26); // Blunt radial nose
                        ctx.lineTo(-8, -10); // Very wide fuselage
                        ctx.lineTo(-23, -6); // Short stubby wings
                        ctx.lineTo(-23, 2);
                        ctx.lineTo(-8, 4);
                        ctx.lineTo(-8, 12);
                        ctx.lineTo(8, 12);
                        ctx.lineTo(8, 4);
                        ctx.lineTo(23, 2);
                        ctx.lineTo(23, -6);
                        ctx.lineTo(8, -10);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;

                    case 'Me-262':
                        // Swept-wing jet fighter with engine nacelles
                        ctx.beginPath();
                        ctx.moveTo(0, -28); // Jet nose
                        ctx.lineTo(-5, -5);
                        ctx.lineTo(-28, 8); // Swept wings!
                        ctx.lineTo(-24, 12);
                        ctx.lineTo(-6, 8);
                        ctx.lineTo(-5, 16); // Jet tail
                        ctx.lineTo(5, 16);
                        ctx.lineTo(6, 8);
                        ctx.lineTo(24, 12);
                        ctx.lineTo(28, 8);
                        ctx.lineTo(5, -5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Engine nacelles
                        ctx.fillRect(-18, 2, 4, 8);
                        ctx.fillRect(14, 2, 4, 8);
                        break;

                    case 'Zero':
                        // Long thin wings, rounded tips
                        ctx.beginPath();
                        ctx.moveTo(0, -30); // Pointed nose
                        ctx.lineTo(-3, -2);
                        ctx.lineTo(-27, -2); // Very long wings
                        ctx.arc(-27, 0, 4, -Math.PI/2, Math.PI/2); // Rounded wingtip
                        ctx.lineTo(-3, 6);
                        ctx.lineTo(-4, 13); // Thin tail
                        ctx.lineTo(4, 13);
                        ctx.lineTo(3, 6);
                        ctx.lineTo(27, 2);
                        ctx.arc(27, 0, 4, Math.PI/2, -Math.PI/2); // Rounded wingtip
                        ctx.lineTo(3, -2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;

                    default:
                        // Generic aircraft (fallback)
                        ctx.beginPath();
                        ctx.moveTo(0, -30);
                        ctx.lineTo(-5, 10);
                        ctx.lineTo(5, 10);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-25, 0);
                        ctx.lineTo(-5, 0);
                        ctx.moveTo(5, 0);
                        ctx.lineTo(25, 0);
                        ctx.stroke();
                        break;
                    }
                }

                // Draw orders indicator
                if (!isGhost && this.hasOrders) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 35, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                // Draw damage effects (smoke and fire) - NOT in ghost mode
                if (!isGhost && !this.isDestroyed) {
                    const now = Date.now();

                    // Heavy damage (70%+) - FIRE
                    if (this.damage >= 70) {
                        for (let i = 0; i < 5; i++) {
                            const flameX = this.x + (Math.random() - 0.5) * 20;
                            const flameY = this.y + (Math.random() - 0.5) * 20;
                            const flameSize = 5 + Math.random() * 8;

                            // Animated fire colors
                            const fireColors = ['rgba(255, 100, 0, 0.8)', 'rgba(255, 150, 0, 0.7)', 'rgba(255, 200, 50, 0.6)'];
                            ctx.fillStyle = fireColors[Math.floor(Math.random() * fireColors.length)];
                            ctx.beginPath();
                            ctx.arc(flameX, flameY, flameSize, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Heavy black smoke with fire
                        for (let i = 0; i < 8; i++) {
                            const smokeX = this.x + (Math.random() - 0.5) * 30 + (Math.random() - 0.5) * 10;
                            const smokeY = this.y - 15 + i * 8 + (Math.random() - 0.5) * 15;
                            const smokeSize = 8 + Math.random() * 10 + i * 1.5;
                            const smokeOpacity = 0.6 - (i * 0.06);

                            ctx.fillStyle = `rgba(30, 30, 30, ${smokeOpacity})`;
                            ctx.beginPath();
                            ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    // Moderate damage (40-70%) - SMOKE only
                    else if (this.damage >= 40) {
                        for (let i = 0; i < 5; i++) {
                            const smokeX = this.x + (Math.random() - 0.5) * 25 + (Math.random() - 0.5) * 8;
                            const smokeY = this.y - 10 + i * 10 + (Math.random() - 0.5) * 12;
                            const smokeSize = 6 + Math.random() * 7 + i * 1.2;
                            const smokeOpacity = 0.4 - (i * 0.06);

                            ctx.fillStyle = `rgba(60, 60, 60, ${smokeOpacity})`;
                            ctx.beginPath();
                            ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                // Draw altitude indicator or destruction label
                if (!isGhost) {
                    if (this.isDestroyed) {
                        ctx.fillStyle = '#ff0000';
                        ctx.font = 'bold 16px Courier New';
                        ctx.fillText('üí• DESTROYED', this.x - 60, this.y - 30);

                        // Smoke effect
                        ctx.fillStyle = 'rgba(50, 50, 50, 0.5)';
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.arc(this.x + (Math.random() - 0.5) * 20, this.y - 10 + (Math.random() - 0.5) * 10, 8 + Math.random() * 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else {
                        ctx.fillStyle = this.isPlayer ? '#0099ff' : '#ff4444';
                        ctx.font = '12px Courier New';
                        ctx.fillText(`${Math.round(this.altitude)}m`, this.x + 20, this.y - 20);

                        // Show inverted indicator
                        if (this.isInverted) {
                            ctx.fillStyle = '#ffaa00';
                            ctx.font = 'bold 14px Courier New';
                            ctx.fillText('‚§∫ INVERTED', this.x - 40, this.y + 40);
                        }

                        // Show rolling indicator with progress
                        if (this.isRolling) {
                            ctx.fillStyle = '#ffaa00';
                            ctx.font = 'bold 12px Courier New';
                            ctx.fillText(`ROLLING ${Math.round(this.rollProgress * 100)}%`, this.x - 35, this.y + 55);
                        }
                    }
                }
            }

            isClicked(mouseX, mouseY) {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < 40 * this.getScaleForAltitude();
            }

            // Calculate speed from throttle setting
            getSpeedFromThrottle() {
                // Linear interpolation between min and max speed based on throttle
                return this.minSpeed + (this.maxSpeed - this.minSpeed) * this.throttle;
            }

            // Calculate realistic flight path using physics simulation
            calculateRealisticPath(targetX, targetY, targetAltitude, targetHeading, slipAngle = 0) {
                const TIME_STEP = 0.1; // 0.1 second time steps
                const NUM_STEPS = Math.floor(turnTime / TIME_STEP); // Variable number of steps based on turn duration
                const g = 9.81;

                // Calculate target speed from current throttle setting
                const targetSpeedFromThrottle = this.getSpeedFromThrottle();

                // Calculate slip/skid physics effects
                const slipAngleRad = Math.abs(slipAngle) * Math.PI / 180;
                const slipSin = Math.sin(slipAngleRad);

                // Drag penalty: increases with sin¬≤(slip angle)
                // At 30¬∞ slip: sin(30¬∞) = 0.5, sin¬≤(30¬∞) = 0.25, drag factor = 1.125 (12.5% more drag)
                const slipDragFactor = 1 + (slipSin * slipSin) * 0.5;

                // G-force reduction: uncoordinated turns are less efficient
                // At 30¬∞ slip: lose 30% of max G capability
                const slipGReduction = Math.abs(slipAngle) / 30 * 0.3;
                const slipEffectiveMaxG = this.maxGForce * (1 - slipGReduction);

                // Path array storing state at each time step
                let path = [];

                // Current state (will be updated each step)
                let state = {
                    x: this.x,
                    y: this.y,
                    altitude: this.altitude,
                    heading: this.heading,
                    speed: targetSpeedFromThrottle, // Use throttle-based speed
                    time: 0
                };

                // Validation tracking
                let overallState = 'valid'; // 'valid', 'stressful', or 'illegal'
                let warnings = [];
                let maxGForce = 0;

                // Add starting point
                path.push({...state});

                for (let step = 0; step < NUM_STEPS; step++) {
                    const stepTime = (step + 1) * TIME_STEP;

                    // Calculate heading difference to reach target heading
                    // Use the targetHeading parameter instead of calculating from position
                    let headingDiff = targetHeading - state.heading;
                    if (headingDiff > 180) headingDiff -= 360;
                    if (headingDiff < -180) headingDiff += 360;

                    // Calculate maximum turn rate based on current speed and G-limits
                    // Turn radius: r = v¬≤ / (g √ó ‚àö(n¬≤ - 1)) where n is load factor (G-force)
                    // For now, use max sustainable G for turn rate calculation (reduced by slip/skid)
                    const maxSustainableG = slipEffectiveMaxG * 0.8; // Use 80% of effective max for sustained
                    const turnRadius = (state.speed * state.speed) / (g * Math.sqrt(maxSustainableG * maxSustainableG - 1));
                    let maxTurnRatePerSec = (state.speed / turnRadius) * (180 / Math.PI); // Convert to degrees/sec

                    // Apply system damage penalties
                    const controlPenalty = 1 - (this.systemDamage.controls * 0.5); // Up to 50% turn rate loss
                    maxTurnRatePerSec = maxTurnRatePerSec * controlPenalty;

                    const maxTurnThisStep = maxTurnRatePerSec * TIME_STEP;

                    // Apply turn rate limit
                    const actualTurn = Math.max(-maxTurnThisStep, Math.min(maxTurnThisStep, headingDiff));
                    const newHeading = (state.heading + actualTurn + 360) % 360;

                    // Store current turn rate for visual banking (degrees per second)
                    this.currentTurnRate = actualTurn / TIME_STEP;

                    // Calculate actual G-force from this turn
                    const turnRateRadPerSec = (Math.abs(actualTurn) / TIME_STEP) * (Math.PI / 180);
                    const actualTurnRadius = turnRateRadPerSec > 0 ? state.speed / turnRateRadPerSec : Infinity;
                    const turnGForce = actualTurnRadius !== Infinity ? (state.speed * state.speed) / (actualTurnRadius * g) : 0;

                    // Calculate desired altitude change
                    const altitudeRemaining = targetAltitude - state.altitude;
                    const timeRemaining = turnTime - stepTime;
                    const desiredClimbRate = timeRemaining > 0 ? altitudeRemaining / timeRemaining : 0;

                    // Limit climb/dive rate
                    let actualClimbRate = desiredClimbRate;
                    if (actualClimbRate > this.maxClimbRate) {
                        actualClimbRate = this.maxClimbRate;
                    } else if (actualClimbRate < -this.maxDiveRate) {
                        actualClimbRate = -this.maxDiveRate;
                    }

                    // Calculate altitude change this step
                    const altitudeChange = actualClimbRate * TIME_STEP;
                    const newAltitude = state.altitude + altitudeChange;

                    // Speed calculation with acceleration limits and energy effects

                    // Step 1: Calculate energy effect from altitude change (diving gains speed, climbing loses speed)
                    // Energy equation: v¬≤ = v‚ÇÄ¬≤ - 2g¬∑Œîh
                    let energyDelta = 0;
                    const energySpeedSquared = state.speed * state.speed - 2 * g * altitudeChange;
                    if (energySpeedSquared > 0) {
                        const energySpeed = Math.sqrt(energySpeedSquared);
                        energyDelta = energySpeed - state.speed; // Positive when diving, negative when climbing
                    } else {
                        energyDelta = this.minSpeed - state.speed; // Would stall
                    }

                    // Step 2: Calculate throttle adjustment towards target speed
                    const speedDiff = targetSpeedFromThrottle - state.speed;
                    let throttleAcceleration = 0;

                    if (speedDiff > 0) {
                        // Need to accelerate
                        throttleAcceleration = Math.min(speedDiff / TIME_STEP, this.maxAcceleration);
                    } else if (speedDiff < 0) {
                        // Need to decelerate
                        throttleAcceleration = Math.max(speedDiff / TIME_STEP, -this.maxBraking);
                    }

                    const throttleDelta = throttleAcceleration * TIME_STEP;

                    // Step 3: Combine energy effect and throttle adjustment
                    // Energy effect happens naturally, throttle tries to compensate
                    let newSpeed = state.speed + energyDelta + throttleDelta;

                    // Combined maneuver energy sharing
                    // Turning while climbing/diving reduces efficiency
                    if (Math.abs(altitudeChange) > 0 && Math.abs(actualTurn) > 0) {
                        const maneuverIntensity = (Math.abs(actualTurn) / maxTurnThisStep) * (Math.abs(actualClimbRate) / this.maxClimbRate);
                        newSpeed *= (1 - maneuverIntensity * 0.1); // Up to 10% speed loss for combined maneuvers
                    }

                    // Step 4: Apply slip/skid drag penalty
                    // Sideways flight creates additional drag that bleeds energy
                    if (slipAngle !== 0) {
                        const slipDragPerStep = (slipDragFactor - 1) * state.speed * TIME_STEP * 0.5; // Drag reduces speed
                        newSpeed -= slipDragPerStep;
                    }

                    // Apply engine damage penalty
                    const enginePenalty = 1 - (this.systemDamage.engine * 0.4); // Up to 40% speed loss
                    newSpeed = newSpeed * enginePenalty;

                    // Clamp speed
                    newSpeed = Math.max(this.minSpeed, Math.min(this.maxSpeed * 1.2, newSpeed));

                    // Move aircraft forward
                    const avgSpeed = (state.speed + newSpeed) / 2;
                    const distance = avgSpeed * TIME_STEP;
                    const headingRad = (newHeading - 90) * Math.PI / 180;
                    const newX = state.x + Math.cos(headingRad) * distance;
                    const newY = state.y + Math.sin(headingRad) * distance;

                    // Check for slip/skid (lateral forces during turn)
                    let slipWarning = null;
                    if (turnGForce > 0) {
                        const bankAngle = Math.atan(turnGForce) * 180 / Math.PI;
                        // Ideally, bank angle should match turn rate
                        // If turning too fast for bank angle, you're skidding
                        // If bank too steep for turn rate, you're slipping
                        // Simplified: warn if turning hard (>50% of max G)
                        if (turnGForce > this.maxGForce * 0.5) {
                            slipWarning = `Skid/Slip at ${stepTime.toFixed(1)}s`;
                        }
                    }

                    // Update state
                    state = {
                        x: newX,
                        y: newY,
                        altitude: newAltitude,
                        heading: newHeading,
                        speed: newSpeed,
                        time: stepTime,
                        gForce: turnGForce,
                        climbRate: actualClimbRate
                    };

                    path.push({...state});

                    // Track max G-force
                    if (turnGForce > maxGForce) maxGForce = turnGForce;

                    // Validation checks
                    // Speed checks
                    if (newSpeed > this.maxSpeed * 1.2) {
                        overallState = 'illegal';
                        warnings.push(`Speed too high at ${stepTime.toFixed(1)}s (${Math.round(newSpeed)} m/s)`);
                    } else if (newSpeed > this.maxSpeed) {
                        if (overallState !== 'illegal') overallState = 'stressful';
                        if (!warnings.some(w => w.includes('Overspeed'))) {
                            warnings.push(`Overspeed at ${stepTime.toFixed(1)}s - Damage`);
                        }
                    } else if (newSpeed < this.minSpeed) {
                        if (overallState !== 'illegal') overallState = 'stressful';
                        if (!warnings.some(w => w.includes('STALL'))) {
                            warnings.push(`STALL WARNING at ${stepTime.toFixed(1)}s`);
                        }
                    }

                    // G-force check
                    if (turnGForce > this.maxGForce) {
                        overallState = 'illegal';
                        warnings.push(`G-force exceeded at ${stepTime.toFixed(1)}s (${turnGForce.toFixed(1)}G)`);
                    } else if (turnGForce > this.maxGForce * 0.85) {
                        if (overallState !== 'illegal') overallState = 'stressful';
                        if (!warnings.some(w => w.includes('High G'))) {
                            warnings.push(`High G-force (${turnGForce.toFixed(1)}G)`);
                        }
                    }

                    // Slip/skid warning
                    if (slipWarning && overallState !== 'illegal') {
                        overallState = 'stressful';
                        if (!warnings.some(w => w.includes('Skid'))) {
                            warnings.push(slipWarning);
                        }
                    }

                    // Intentional slip/skid angle warnings
                    if (Math.abs(slipAngle) > 20) {
                        if (overallState !== 'illegal') overallState = 'stressful';
                        if (!warnings.some(w => w.includes('Slip/Skid'))) {
                            warnings.push(`High Slip/Skid Angle (${Math.abs(slipAngle)}¬∞) - Increased drag`);
                        }
                    }
                    // Extreme slip at low speed risks accelerated stall
                    if (Math.abs(slipAngle) > 20 && newSpeed < this.minSpeed * 1.2) {
                        if (overallState !== 'illegal') overallState = 'stressful';
                        if (!warnings.some(w => w.includes('Accelerated stall'))) {
                            warnings.push(`‚ö† Accelerated stall risk - slip + low speed`);
                        }
                    }

                    // Terrain check
                    const terrainHeight = terrain.getHeightAt(newX, newY);
                    if (newAltitude < terrainHeight + 50) {
                        overallState = 'illegal';
                        warnings.push(`‚ö† TERRAIN at ${stepTime.toFixed(1)}s ‚ö†`);
                    }
                }

                // Final position check - how close did we get?
                const finalState = path[path.length - 1];
                const finalDist = Math.sqrt((finalState.x - targetX)**2 + (finalState.y - targetY)**2);
                const finalAltDiff = Math.abs(finalState.altitude - targetAltitude);
                const finalHeadingDiff = Math.abs(finalState.heading - targetHeading);

                // Check altitude achievement
                const requestedAltChange = targetAltitude - this.altitude;
                const maxPossibleClimb = this.maxClimbRate * turnTime;
                const maxPossibleDive = this.maxDiveRate * turnTime;

                if (requestedAltChange > maxPossibleClimb) {
                    if (overallState !== 'illegal') overallState = 'stressful';
                    warnings.push(`Climb too steep - max ${Math.round(maxPossibleClimb)}m in ${turnTime}s`);
                } else if (requestedAltChange < -maxPossibleDive) {
                    if (overallState !== 'illegal') overallState = 'stressful';
                    warnings.push(`Dive too steep - max ${Math.round(maxPossibleDive)}m in ${turnTime}s`);
                } else if (finalAltDiff > 20) {
                    // Couldn't reach target altitude even though it should be possible
                    if (overallState !== 'illegal') overallState = 'stressful';
                    warnings.push(`Altitude missed by ${Math.round(finalAltDiff)}m`);
                }

                if (finalDist > 100) {
                    if (overallState !== 'illegal') overallState = 'stressful';
                    warnings.push(`Won't reach target (${Math.round(finalDist)}m short)`);
                }

                return {
                    path: path,
                    state: overallState,
                    warnings: warnings,
                    targetSpeed: Math.round(finalState.speed),
                    gForce: maxGForce.toFixed(1),
                    climbRate: Math.round(Math.abs(finalState.climbRate)),
                    targetAltitude: Math.round(targetAltitude),
                    targetHeading: Math.round(targetHeading),
                    finalX: finalState.x,
                    finalY: finalState.y,
                    finalAltitude: finalState.altitude,
                    finalFlightHeading: finalState.heading // Actual flight heading achieved (not nose heading)
                };
            }

            // Calculate Immelmann Turn: half loop up + half roll to reverse direction while gaining altitude
            calculateImmelmannPath() {
                const TIME_STEP = 0.1;
                const NUM_STEPS = Math.floor(turnTime / TIME_STEP);
                const path = [];

                // Immelmann requires minimum speed (120 m/s)
                const startSpeed = Math.max(120, this.speed);
                const loopRadius = (startSpeed * startSpeed) / (this.maxGForce * 9.81); // Physics: r = v¬≤/g
                const halfLoopTime = (Math.PI * loopRadius) / startSpeed; // Time for half loop

                let currentHeading = this.heading;
                let currentAltitude = this.altitude;
                let currentX = this.x;
                let currentY = this.y;
                let currentSpeed = startSpeed;

                for (let i = 0; i <= NUM_STEPS; i++) {
                    const progress = i / NUM_STEPS;
                    const time = progress * turnTime;

                    if (time < halfLoopTime) {
                        // First half: climb in a loop
                        const loopProgress = time / halfLoopTime;
                        const angle = loopProgress * Math.PI; // 0 to œÄ (180¬∞)

                        // Calculate position on circular arc
                        const arcX = Math.sin(angle) * loopRadius;
                        const arcY = -(1 - Math.cos(angle)) * loopRadius; // Negative because climbing

                        // Rotate arc based on initial heading
                        const headingRad = (currentHeading - 90) * Math.PI / 180;
                        currentX = this.x + (arcX * Math.cos(headingRad) - arcY * Math.sin(headingRad));
                        currentY = this.y + (arcX * Math.sin(headingRad) + arcY * Math.cos(headingRad));
                        currentAltitude = this.altitude + (1 - Math.cos(angle)) * loopRadius;

                        // Aircraft heading follows the loop
                        currentHeading = (this.heading + angle * 180 / Math.PI) % 360;

                        // Speed bleeds off during climb
                        currentSpeed = startSpeed * (1 - 0.3 * loopProgress);

                        // High G-force during loop (4-6G)
                        this.currentGForce = 1 + Math.sin(angle) * 5;
                    } else {
                        // Second half: roll to upright while continuing forward
                        // At top of loop, heading is reversed, now roll to upright
                        const rollProgress = (time - halfLoopTime) / (turnTime - halfLoopTime);

                        // Continue forward at reduced speed
                        const forwardDist = (time - halfLoopTime) * currentSpeed;
                        const headingRad = (this.heading + 180) * Math.PI / 180;
                        currentX = this.x + (Math.sin(angle) * loopRadius + forwardDist) * Math.cos(headingRad - Math.PI/2);
                        currentY = this.y + (Math.sin(angle) * loopRadius + forwardDist) * Math.sin(headingRad - Math.PI/2);

                        // Maintain altitude
                        currentAltitude = this.altitude + loopRadius * 2;
                        currentHeading = (this.heading + 180) % 360;

                        // Recover from G-forces
                        this.currentGForce = 1 + (1 - rollProgress) * 2;
                    }

                    path.push({
                        x: currentX,
                        y: currentY,
                        altitude: currentAltitude,
                        heading: currentHeading,
                        speed: currentSpeed
                    });
                }

                this.flightPath = path;
                return { path, valid: startSpeed >= 120 };
            }

            // Calculate Split-S: half roll inverted + half loop down to reverse direction while losing altitude
            calculateSplitSPath() {
                const TIME_STEP = 0.1;
                const NUM_STEPS = Math.floor(turnTime / TIME_STEP);
                const path = [];

                // Split-S requires sufficient altitude (500m minimum)
                const startSpeed = this.speed;
                const loopRadius = (startSpeed * startSpeed) / (this.maxGForce * 9.81);
                const halfRollTime = turnTime * 0.3; // Roll takes 30% of maneuver
                const halfLoopTime = (Math.PI * loopRadius) / startSpeed;

                let currentHeading = this.heading;
                let currentAltitude = this.altitude;
                let currentX = this.x;
                let currentY = this.y;
                let currentSpeed = startSpeed;

                for (let i = 0; i <= NUM_STEPS; i++) {
                    const progress = i / NUM_STEPS;
                    const time = progress * turnTime;

                    if (time < halfRollTime) {
                        // First: roll inverted
                        const rollProgress = time / halfRollTime;
                        // Continue mostly straight while rolling
                        const forwardDist = time * currentSpeed;
                        const headingRad = this.heading * Math.PI / 180;
                        currentX = this.x + forwardDist * Math.cos(headingRad - Math.PI/2);
                        currentY = this.y + forwardDist * Math.sin(headingRad - Math.PI/2);
                        currentAltitude = this.altitude; // Slight loss
                        currentHeading = this.heading;

                        this.currentGForce = 1 + Math.sin(rollProgress * Math.PI) * 2;
                    } else {
                        // Second: dive in half loop
                        const loopProgress = (time - halfRollTime) / halfLoopTime;
                        const angle = loopProgress * Math.PI; // 0 to œÄ

                        // Calculate position on circular arc (diving)
                        const arcX = Math.sin(angle) * loopRadius;
                        const arcY = (1 - Math.cos(angle)) * loopRadius; // Positive because diving

                        // Rotate arc based on heading
                        const headingRad = (this.heading - 90) * Math.PI / 180;
                        const rollDist = halfRollTime * startSpeed;
                        const baseX = this.x + rollDist * Math.cos(this.heading * Math.PI / 180 - Math.PI/2);
                        const baseY = this.y + rollDist * Math.sin(this.heading * Math.PI / 180 - Math.PI/2);

                        currentX = baseX + (arcX * Math.cos(headingRad) - arcY * Math.sin(headingRad));
                        currentY = baseY + (arcX * Math.sin(headingRad) + arcY * Math.cos(headingRad));
                        currentAltitude = this.altitude - (1 - Math.cos(angle)) * loopRadius;

                        // Heading reverses through the dive
                        currentHeading = (this.heading + angle * 180 / Math.PI) % 360;

                        // Speed increases in dive
                        currentSpeed = startSpeed * (1 + 0.4 * loopProgress);

                        // High G-force during dive pull-out
                        this.currentGForce = 1 + Math.sin(angle) * 5;
                    }

                    path.push({
                        x: currentX,
                        y: currentY,
                        altitude: Math.max(0, currentAltitude),
                        heading: currentHeading,
                        speed: currentSpeed
                    });
                }

                this.flightPath = path;
                return { path, valid: this.altitude >= 500 };
            }

            // Calculate Full Loop: complete vertical loop returning to original heading
            calculateLoopPath() {
                const TIME_STEP = 0.1;
                const NUM_STEPS = Math.floor(turnTime / TIME_STEP);
                const path = [];

                // Loop requires high speed (140 m/s minimum) and altitude
                const startSpeed = Math.max(140, this.speed);
                const loopRadius = (startSpeed * startSpeed) / (this.maxGForce * 9.81);

                for (let i = 0; i <= NUM_STEPS; i++) {
                    const progress = i / NUM_STEPS;
                    const angle = progress * 2 * Math.PI; // Full 360¬∞

                    // Calculate position on circular arc
                    const arcX = Math.sin(angle) * loopRadius;
                    const arcY = -(1 - Math.cos(angle)) * loopRadius;

                    // Rotate arc based on initial heading
                    const headingRad = (this.heading - 90) * Math.PI / 180;
                    const currentX = this.x + (arcX * Math.cos(headingRad) - arcY * Math.sin(headingRad));
                    const currentY = this.y + (arcX * Math.sin(headingRad) + arcY * Math.cos(headingRad));
                    const currentAltitude = this.altitude + (1 - Math.cos(angle)) * loopRadius;

                    // Speed varies: loses speed climbing, gains diving
                    let currentSpeed = startSpeed;
                    if (progress < 0.5) {
                        currentSpeed = startSpeed * (1 - 0.4 * progress * 2);
                    } else {
                        currentSpeed = startSpeed * (0.6 + 0.4 * (progress - 0.5) * 2);
                    }

                    // G-force peaks at bottom and top
                    this.currentGForce = 1 + Math.abs(Math.sin(angle)) * 5;

                    path.push({
                        x: currentX,
                        y: currentY,
                        altitude: Math.max(this.altitude, currentAltitude),
                        heading: (this.heading + angle * 180 / Math.PI) % 360,
                        speed: currentSpeed
                    });
                }

                this.flightPath = path;
                return { path, valid: startSpeed >= 140 && this.altitude >= loopRadius };
            }

            // Calculate Half Loop: half of vertical loop (ends inverted, heading reversed, altitude gained)
            calculateHalfLoopPath() {
                const TIME_STEP = 0.1;
                const NUM_STEPS = Math.floor(turnTime / TIME_STEP);
                const path = [];

                // Half loop requires good speed (130 m/s minimum)
                const startSpeed = Math.max(130, this.speed);
                const loopRadius = (startSpeed * startSpeed) / (this.maxGForce * 9.81);

                for (let i = 0; i <= NUM_STEPS; i++) {
                    const progress = i / NUM_STEPS;
                    const angle = progress * Math.PI; // Half loop: 0 to œÄ

                    // Calculate position on circular arc
                    const arcX = Math.sin(angle) * loopRadius;
                    const arcY = -(1 - Math.cos(angle)) * loopRadius;

                    // Rotate arc based on initial heading
                    const headingRad = (this.heading - 90) * Math.PI / 180;
                    const currentX = this.x + (arcX * Math.cos(headingRad) - arcY * Math.sin(headingRad));
                    const currentY = this.y + (arcX * Math.sin(headingRad) + arcY * Math.cos(headingRad));
                    const currentAltitude = this.altitude + (1 - Math.cos(angle)) * loopRadius;

                    // Speed bleeds off during climb
                    const currentSpeed = startSpeed * (1 - 0.3 * progress);

                    // G-force during climb
                    this.currentGForce = 1 + Math.sin(angle) * 5;

                    path.push({
                        x: currentX,
                        y: currentY,
                        altitude: currentAltitude,
                        heading: (this.heading + angle * 180 / Math.PI) % 360,
                        speed: currentSpeed
                    });
                }

                this.flightPath = path;
                return { path, valid: startSpeed >= 130 };
            }

            calculateManeuverValidation(targetX, targetY, targetAltitude, targetHeading, slipAngle = 0) {
                // Check if we're doing a special maneuver
                if (this.maneuverType === 'immelmann') {
                    return this.calculateImmelmannPath();
                } else if (this.maneuverType === 'split-s') {
                    return this.calculateSplitSPath();
                } else if (this.maneuverType === 'loop') {
                    return this.calculateLoopPath();
                } else if (this.maneuverType === 'half-loop') {
                    return this.calculateHalfLoopPath();
                }

                // Use the new realistic path calculation
                const result = this.calculateRealisticPath(targetX, targetY, targetAltitude, targetHeading, slipAngle);

                // Store the path for rendering and execution
                this.flightPath = result.path;

                return result;
            }

            lockOrders(targetX, targetY, targetAltitude, targetHeading, slipAngle = 0) {
                // Save starting position for interpolation
                this.startX = this.x;
                this.startY = this.y;
                this.startAltitude = this.altitude;
                this.startHeading = this.heading;
                this.startSpeed = this.speed;

                this.targetX = targetX;
                this.targetY = targetY;
                this.targetAltitude = targetAltitude;
                this.targetHeading = targetHeading;
                this.slipAngle = slipAngle; // Save slip angle for execution
                this.hasOrders = true;

                // Calculate target speed: distance / time
                const dx = targetX - this.startX;
                const dy = targetY - this.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.targetSpeed = distance / turnTime;
            }

            unlockOrders() {
                this.hasOrders = false;
                this.targetX = this.x;
                this.targetY = this.y;
                this.targetAltitude = this.altitude;
                this.targetHeading = this.heading;
            }

            executeOrders(progress) {
                // progress goes from 0 to 1

                // Handle roll mechanics during execution
                if (this.rollType !== 'none') {
                    // Roll happens smoothly over first 40% of maneuver
                    const rollDuration = 0.4;
                    if (progress <= rollDuration) {
                        this.isRolling = true;
                        this.rollProgress = progress / rollDuration;

                        // Calculate if inverted based on roll type and progress
                        if (this.rollType === 'half') {
                            // Half roll: become inverted at 50% and stay inverted
                            this.isInverted = this.rollProgress >= 0.5;
                        } else if (this.rollType === 'full') {
                            // Full roll: inverted from 25% to 75%, then right-side up
                            this.isInverted = this.rollProgress >= 0.25 && this.rollProgress < 0.75;
                        }

                        // Add G-force spike during roll (2-3G)
                        this.currentGForce = 1.0 + (Math.sin(this.rollProgress * Math.PI) * 2.0);
                    } else {
                        this.isRolling = false;
                        this.rollProgress = 1.0;
                        this.currentGForce = 1.0;
                        // Maintain inverted state if half roll
                        if (this.rollType === 'half') {
                            this.isInverted = true;
                        } else if (this.rollType === 'full') {
                            this.isInverted = false;
                        }
                    }
                } else {
                    this.isRolling = false;
                    this.rollProgress = 0;
                    this.isInverted = false;
                    this.currentGForce = 1.0;
                }

                // Follow the precalculated realistic flight path
                if (this.flightPath && this.flightPath.length > 1) {
                    // Find the point in the path corresponding to current progress
                    const pathIndex = Math.floor(progress * (this.flightPath.length - 1));
                    const nextIndex = Math.min(pathIndex + 1, this.flightPath.length - 1);

                    // Interpolate between path points for smooth animation
                    const localProgress = (progress * (this.flightPath.length - 1)) - pathIndex;

                    const current = this.flightPath[pathIndex];
                    const next = this.flightPath[nextIndex];

                    this.x = current.x + (next.x - current.x) * localProgress;
                    this.y = current.y + (next.y - current.y) * localProgress;
                    this.altitude = current.altitude + (next.altitude - current.altitude) * localProgress;

                    // Flight heading from path (direction of movement)
                    const flightHeading = current.heading + (next.heading - current.heading) * localProgress;

                    // Nose heading = flight heading + slip angle
                    this.heading = (flightHeading + this.slipAngle + 360) % 360;
                    this.speed = current.speed + (next.speed - current.speed) * localProgress;

                    // Check for stall condition
                    if (this.speed < this.minSpeed) {
                        this.inStall = true;
                    }

                    // Track G-forces from maneuvers (combine path G-force with roll G-force)
                    const pathGForce = current.gForce || 1.0;
                    this.currentGForce = Math.max(this.currentGForce, pathGForce);
                    this.peakGForce = Math.max(this.peakGForce, this.currentGForce);

                    // Apply damage for stressful maneuvers
                    if (this.currentGForce > this.maxGForce * 0.85) {
                        this.damage += 0.1; // Gradual damage from high G
                    }
                } else {
                    // Fallback to old linear interpolation if no path (shouldn't happen)
                    this.x = this.startX + (this.targetX - this.startX) * progress;
                    this.y = this.startY + (this.targetY - this.startY) * progress;
                    this.altitude = this.startAltitude + (this.targetAltitude - this.startAltitude) * progress;

                    let headingDiff = this.targetHeading - this.startHeading;
                    if (headingDiff > 180) headingDiff -= 360;
                    if (headingDiff < -180) headingDiff += 360;
                    this.heading = this.startHeading + headingDiff * progress;

                    if (this.heading < 0) this.heading += 360;
                    if (this.heading >= 360) this.heading -= 360;

                    this.speed = this.startSpeed + (this.targetSpeed - this.startSpeed) * progress;
                }
            }

            finalizeExecution() {
                // Use actual final position from flight path (not desired target)
                // This prevents jumping when physics prevents reaching exact target
                if (this.flightPath && this.flightPath.length > 0) {
                    const finalState = this.flightPath[this.flightPath.length - 1];
                    this.x = finalState.x;
                    this.y = finalState.y;
                    this.altitude = finalState.altitude;
                    // Apply slip angle to final heading (nose vs flight direction)
                    const flightHeading = finalState.heading;
                    this.heading = (flightHeading + this.slipAngle + 360) % 360;
                    this.speed = finalState.speed;
                } else {
                    // Fallback if no flight path (shouldn't happen)
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.altitude = this.targetAltitude;
                    this.heading = this.targetHeading;
                    this.speed = this.targetSpeed;
                }

                // Calculate G-force penalty for next turn
                // High G-forces reduce pilot skill for the next turn
                if (this.peakGForce > 4.0) {
                    // Penalty scales with G-force: 4G = 10% penalty, 7G = 40% penalty
                    this.gForcePenalty = Math.min(0.5, (this.peakGForce - 4.0) * 0.1);
                    console.log(`${this.name} experienced ${this.peakGForce.toFixed(1)}G - skill penalty: ${(this.gForcePenalty * 100).toFixed(0)}% next turn`);
                } else {
                    this.gForcePenalty = 0;
                }

                // Reset roll state and G-force tracking for next turn
                this.rollType = 'none';
                this.isRolling = false;
                this.rollProgress = 0;
                this.peakGForce = 1.0;
                this.currentGForce = 1.0;
                this.currentTurnRate = 0; // Reset turn rate for next turn
                // Keep isInverted state if half roll was performed

                this.hasOrders = false;
            }

            getStatsHTML() {
                const ammoColor = this.ammunition < 100 ? 'color: #ff4444;' : '';
                const ammoPercent = Math.round((this.ammunition / this.maxAmmunition) * 100);
                const damageColor = this.damage > 50 ? 'color: #ff4444;' : this.damage > 25 ? 'color: #ffaa00;' : '';
                const hitWarning = this.lastHitBy ? `<div style="color: #ff0000; animation: blink 0.5s infinite;">‚ö† HIT BY ${this.lastHitBy.toUpperCase()}!</div>` : '';

                // Enhancement #12: Fuel display
                const fuelPercent = Math.round((this.fuel / this.maxFuel) * 100);
                const fuelColor = fuelPercent < 20 ? 'color: #ff4444;' : fuelPercent < 40 ? 'color: #ffaa00;' : '';
                const fuelDisplay = gameSettings.enableFuel ?
                    `<div class="stat-line" style="${fuelColor}">Fuel: ${fuelPercent}%</div>` : '';
                const fuelLeakWarning = this.fuelLeak ?
                    `<div class="stat-line" style="color: #ff4444;">‚ö† FUEL LEAK!</div>` : '';

                // Enhancement #4: Component damage display
                let componentInfo = '';
                if (gameSettings.enableComponentDamage && (this.componentDamage.engine > 10 || this.componentDamage.wings > 10 || this.componentDamage.cockpit > 10)) {
                    componentInfo = '<div class="stat-line" style="font-size: 11px; color: #ffaa00;">';
                    if (this.componentDamage.engine > 10) componentInfo += `Engine: ${Math.round(this.componentDamage.engine)}% `;
                    if (this.componentDamage.leftWing > 10 || this.componentDamage.rightWing > 10) {
                        componentInfo += `Wings: L${Math.round(this.componentDamage.leftWing)}%/R${Math.round(this.componentDamage.rightWing)}% `;
                    }
                    if (this.componentDamage.cockpit > 10) componentInfo += `Cockpit: ${Math.round(this.componentDamage.cockpit)}% `;
                    componentInfo += '</div>';
                }

                // Show G-force during execution
                const gForceDisplay = this.currentGForce > 1.5 ? `<div class="stat-line" style="color: #ffaa00;">G-Force: ${this.currentGForce.toFixed(1)}G</div>` : '';

                // Show G-force penalty from previous turn
                const gPenaltyDisplay = this.gForcePenalty > 0 ?
                    `<div class="stat-line" style="color: #ff8800;">‚ö† G-Strain: -${Math.round(this.gForcePenalty * 100)}% skill</div>` : '';

                // Show inverted status
                const invertedDisplay = this.isInverted ?
                    `<div class="stat-line" style="color: #ffaa00;">‚§∫ INVERTED</div>` : '';

                // Show pilot wounded
                const pilotWoundedDisplay = this.pilotWounded ?
                    `<div class="stat-line" style="color: #ff4444;">‚ö† PILOT WOUNDED</div>` : '';

                // Show fire threshold
                const fireThresholdPercent = Math.round(this.fireThreshold * 100);
                const fireThresholdColor = this.fireThreshold < 0.20 ? '#ff4444' :
                                          this.fireThreshold < 0.30 ? '#ffaa00' : '#88ff88';

                // Enhancement #8: Weapon info
                const weaponName = this.weaponType === 'mg' ? 'MGs' :
                                  this.weaponType === 'hmg' ? 'HMGs' : 'Cannon';

                // Enhancement #8: Bombs/Rockets (if available)
                const ordinanceDisplay = (this.bombs > 0 || this.rockets > 0) ?
                    `<div class="stat-line" style="color: #88ff88;">Bombs: ${this.bombs} | Rockets: ${this.rockets}</div>` : '';

                // Show critical hits
                const critDisplay = this.criticalHitsDealt > 0 ?
                    `<div class="stat-line" style="color: #ff8800;">üí• Crits: ${this.criticalHitsDealt}</div>` : '';
                const critTakenDisplay = this.criticalHitsTaken > 0 ?
                    `<div class="stat-line" style="color: #ff4444;">üí• Hit by: ${this.criticalHitsTaken}</div>` : '';

                // Show system damage
                const engineDamageDisplay = this.systemDamage.engine > 0 ?
                    `<div class="stat-line" style="color: #ff4444;">üîß Engine: ${Math.round(this.systemDamage.engine * 100)}%</div>` : '';
                const controlDamageDisplay = this.systemDamage.controls > 0 ?
                    `<div class="stat-line" style="color: #ff4444;">‚öô Controls: ${Math.round(this.systemDamage.controls * 100)}%</div>` : '';
                const weaponDamageDisplay = this.systemDamage.weapons > 0 ?
                    `<div class="stat-line" style="color: #ff4444;">üéØ Weapons: ${Math.round(this.systemDamage.weapons * 100)}%</div>` : '';

                return `
                    <div class="stat-line" style="font-size: 11px; color: #aaa;">${this.fullName}</div>
                    <div class="stat-line">Alt: ${Math.round(this.altitude)}m</div>
                    <div class="stat-line">Speed: ${Math.round(this.speed)} m/s</div>
                    <div class="stat-line">Throttle: ${Math.round(this.throttle * 100)}%</div>
                    <div class="stat-line">Hdg: ${Math.round(this.heading)}¬∞</div>
                    ${fuelDisplay}
                    ${fuelLeakWarning}
                    <div class="stat-line" style="${ammoColor}">${weaponName}: ${ammoPercent}% ${this.isFiring ? 'üî•' : ''}</div>
                    <div class="stat-line" style="${damageColor}">Damage: ${Math.round(this.damage)}%</div>
                    ${componentInfo}
                    <div class="stat-line" style="color: ${fireThresholdColor}">Fire Min: ${fireThresholdPercent}%</div>
                    ${ordinanceDisplay}
                    ${critDisplay}
                    ${critTakenDisplay}
                    ${engineDamageDisplay}
                    ${controlDamageDisplay}
                    ${weaponDamageDisplay}
                    ${gForceDisplay}
                    ${gPenaltyDisplay}
                    ${invertedDisplay}
                    ${pilotWoundedDisplay}
                    ${hitWarning}
                `;
            }
        }

        // Critical hit calculation
        function calculateCriticalHitChance(shooter, target, distance, angleDiff) {
            let critChance = 0.10; // Base 10% chance

            // Optimal range bonus (200-400 pixels = point blank range)
            if (distance < 400 && distance > 200) {
                critChance += 0.15; // +15% at optimal range
            }

            // Deflection shot penalty (harder to hit critical components)
            if (angleDiff > 10) {
                critChance -= 0.05;
            }

            // Perfect angle bonus (dead-on shot)
            if (angleDiff < 5 && distance < 300) {
                critChance += 0.10; // +10% for perfect shot
            }

            // G-force penalty (harder to aim under stress)
            if (shooter.currentGForce > 3.0) {
                critChance -= (shooter.currentGForce - 3.0) * 0.05;
            }

            // Weapon system damage reduces crit chance
            if (shooter.systemDamage.weapons > 0) {
                critChance -= shooter.systemDamage.weapons * 0.15;
            }

            // Target's control damage increases vulnerability
            if (target.systemDamage.controls > 0.3) {
                critChance += 0.10; // +10% against damaged aircraft
            }

            return Math.max(0, Math.min(0.50, critChance)); // Cap between 0-50%
        }

        // Apply critical hit effects
        function applyCriticalHit(target, weapon) {
            target.criticalHitsTaken++;

            // Randomly select which system gets damaged
            const systems = ['engine', 'controls', 'weapons'];
            const hitSystem = systems[Math.floor(Math.random() * systems.length)];

            // Damage amount based on weapon type
            let damageAmount = weapon === 'cannon' ? 0.25 : 0.15; // Cannon does more system damage

            // Apply damage (cumulative but capped at 1.0)
            target.systemDamage[hitSystem] = Math.min(1.0, target.systemDamage[hitSystem] + damageAmount);

            console.log(`üí• CRITICAL HIT! ${target.name} ${hitSystem} damaged: ${Math.round(target.systemDamage[hitSystem] * 100)}%`);

            // Apply extra hull damage for critical hit
            const bonusDamage = weapon === 'cannon' ? 15 : 8;
            target.damage += bonusDamage;

            // Create visual feedback
            target.hitEffects.push({
                x: target.x,
                y: target.y,
                type: 'critical',
                time: Date.now(),
                duration: 1500 // Critical hits show longer
            });
        }

        // Initialize game
        const terrain = new Terrain();
        let spitfire = null;
        let me109 = null;
        let aircraft = [];

        // AI for Me-109 - Tactical Dogfight AI
        function generateAIOrders(aiAircraft = null) {
            // If no aircraft specified, use me109 for backward compatibility
            if (!aiAircraft) aiAircraft = me109;

            if (aiAircraft.hasOrders) return;
            if (aiAircraft.isDestroyed) return; // Dead AI can't give orders

            // Check if this is a wingman - use wingman AI instead
            if (aiAircraft.isWingman) {
                applyWingmanAI(aiAircraft);
                aiAircraft.hasOrders = true;
                return;
            }

            // Find target (closest enemy aircraft)
            let target = null;
            let minDist = Infinity;
            for (let plane of aircraft) {
                if (plane.isPlayer === aiAircraft.isPlayer || plane.isDestroyed) continue;
                const dx2 = plane.x - aiAircraft.x;
                const dy2 = plane.y - aiAircraft.y;
                const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                if (dist < minDist) {
                    minDist = dist;
                    target = plane;
                }
            }

            if (!target) return; // No target to attack

            // ===== SITUATIONAL AWARENESS =====

            // Calculate relative positions
            const dx = target.x - aiAircraft.x;
            const dy = target.y - aiAircraft.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angleToEnemy = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;

            // Calculate angle difference from my heading to enemy
            let myAngleToEnemy = angleToEnemy - aiAircraft.heading;
            if (myAngleToEnemy > 180) myAngleToEnemy -= 360;
            if (myAngleToEnemy < -180) myAngleToEnemy += 360;

            // Calculate angle from enemy's heading to me (am I behind them?)
            const angleFromEnemyToMe = (Math.atan2(-dy, -dx) * 180 / Math.PI + 360) % 360;
            let enemyAngleToMe = angleFromEnemyToMe - target.heading;
            if (enemyAngleToMe > 180) enemyAngleToMe -= 360;
            if (enemyAngleToMe < -180) enemyAngleToMe += 360;

            // Energy states (altitude = potential energy, speed = kinetic energy)
            const myEnergy = aiAircraft.altitude + (aiAircraft.speed * 0.5); // Simple energy metric
            const enemyEnergy = target.altitude + (target.speed * 0.5);
            const energyAdvantage = myEnergy - enemyEnergy;

            // Positional assessment
            const isBehindEnemy = Math.abs(enemyAngleToMe) > 120; // Enemy not facing me
            const enemyBehindMe = Math.abs(myAngleToEnemy) > 120; // I'm not facing enemy
            const inFiringPosition = isBehindEnemy && distance < 300 && Math.abs(myAngleToEnemy) < 30;
            const underAttack = enemyBehindMe && distance < 400;

            // ===== DECISION MAKING =====

            let targetX, targetY, targetAltitude, targetHeading;
            let aiThrottle = aiAircraft.throttle;
            let useSlip = 0;

            // STATE 1: DEFENSIVE - Enemy is behind me, evade!
            if (underAttack) {
                console.log(`${aiAircraft.name} AI: DEFENSIVE - Evading!`);

                // Break turn - hard turn perpendicular to enemy
                const breakDirection = myAngleToEnemy > 0 ? 90 : -90;
                const breakHeading = (aiAircraft.heading + breakDirection + 360) % 360;

                // Turn hard and dive for speed (or climb if low)
                const diveOrClimb = aiAircraft.altitude > 300 ? -100 : 50;
                targetAltitude = Math.max(ALTITUDE_MIN, Math.min(ALTITUDE_MAX, aiAircraft.altitude + diveOrClimb));

                // Move in break direction
                const breakDistance = 250;
                targetX = aiAircraft.x + Math.cos((breakHeading - 90) * Math.PI / 180) * breakDistance;
                targetY = aiAircraft.y + Math.sin((breakHeading - 90) * Math.PI / 180) * breakDistance;
                targetHeading = breakHeading;

                // Full throttle for evasion
                aiThrottle = 1.0;

            // STATE 2: OFFENSIVE - I'm in good position, press the attack!
            } else if (isBehindEnemy && Math.abs(myAngleToEnemy) < 60) {
                console.log(`${aiAircraft.name} AI: OFFENSIVE - Attacking!`);

                // Lead the target - predict where they'll be
                const leadDistance = distance * 0.3;
                const predictedX = target.x + Math.cos((target.heading - 90) * Math.PI / 180) * leadDistance;
                const predictedY = target.y + Math.sin((target.heading - 90) * Math.PI / 180) * leadDistance;

                targetX = predictedX;
                targetY = predictedY;

                // Match enemy altitude (slight advantage)
                targetAltitude = Math.max(ALTITUDE_MIN, Math.min(ALTITUDE_MAX, target.altitude + 50));

                // Face the predicted position
                const dxPred = predictedX - aiAircraft.x;
                const dyPred = predictedY - aiAircraft.y;
                targetHeading = (Math.atan2(dyPred, dxPred) * 180 / Math.PI + 90 + 360) % 360;

                // Use slip for gun solution if very close
                if (distance < 200 && inFiringPosition) {
                    useSlip = Math.random() > 0.5 ? 10 : -10; // Random slip for deflection shot
                }

                // Moderate throttle to maintain position
                aiThrottle = 0.8;

            // STATE 3: ENERGY ADVANTAGE - Use altitude for boom and zoom
            } else if (energyAdvantage > 200 && aiAircraft.altitude > target.altitude + 150) {
                console.log(`${aiAircraft.name} AI: ENERGY ADVANTAGE - Boom and Zoom!`);

                // Dive towards enemy for speed advantage
                targetX = target.x;
                targetY = target.y;
                targetAltitude = Math.max(ALTITUDE_MIN, target.altitude + 100); // Dive to near their altitude

                // Point nose at enemy
                targetHeading = angleToEnemy;

                // Full throttle for the dive
                aiThrottle = 1.0;

            // STATE 4: ENERGY RECOVERY - Low energy, gain altitude
            } else if (aiAircraft.speed < aiAircraft.minSpeed * 1.3 || (energyAdvantage < -200 && aiAircraft.altitude < 800)) {
                console.log(`${aiAircraft.name} AI: ENERGY RECOVERY - Gaining altitude!`);

                // Climb away from enemy to gain energy
                const escapeHeading = (angleToEnemy + 180 + 360) % 360; // Opposite direction
                targetHeading = escapeHeading;

                targetX = aiAircraft.x + Math.cos((escapeHeading - 90) * Math.PI / 180) * 200;
                targetY = aiAircraft.y + Math.sin((escapeHeading - 90) * Math.PI / 180) * 200;

                // Climb for energy
                targetAltitude = Math.min(ALTITUDE_MAX, aiAircraft.altitude + 100);

                // Full throttle for climb
                aiThrottle = 1.0;

            // STATE 5: NEUTRAL - Maneuver for position
            } else {
                console.log(`${aiAircraft.name} AI: NEUTRAL - Maneuvering for position`);

                // Try to get to enemy's 6 o'clock (behind them)
                const behindDistance = 200;
                const behindX = target.x - Math.cos((target.heading - 90) * Math.PI / 180) * behindDistance;
                const behindY = target.y - Math.sin((target.heading - 90) * Math.PI / 180) * behindDistance;

                targetX = behindX;
                targetY = behindY;

                // Slight altitude advantage
                targetAltitude = Math.max(ALTITUDE_MIN, Math.min(ALTITUDE_MAX, target.altitude + 100));

                // Face towards the behind position
                const dxBehind = behindX - aiAircraft.x;
                const dyBehind = behindY - aiAircraft.y;
                targetHeading = (Math.atan2(dyBehind, dxBehind) * 180 / Math.PI + 90 + 360) % 360;

                // Moderate throttle
                aiThrottle = 0.8;
            }

            // ===== APPLY THROTTLE SETTING =====
            aiAircraft.throttle = Math.max(0.0, Math.min(1.0, aiThrottle));

            // ===== VALIDATE AND EXECUTE =====

            // Constrain to canvas
            targetX = Math.max(50, Math.min(CANVAS_WIDTH - 50, targetX));
            targetY = Math.max(50, Math.min(CANVAS_HEIGHT - 50, targetY));

            // Validate maneuver
            const validation = aiAircraft.calculateManeuverValidation(targetX, targetY, targetAltitude, targetHeading, useSlip);

            if (validation.state !== 'illegal') {
                // Use actual final position from physics calculation
                aiAircraft.lockOrders(
                    validation.finalX,
                    validation.finalY,
                    validation.finalAltitude,
                    validation.finalFlightHeading,
                    useSlip
                );
            } else {
                // Fallback: simple forward movement with current heading
                const fallbackDistance = 150;
                const fallbackX = aiAircraft.x + Math.cos((aiAircraft.heading - 90) * Math.PI / 180) * fallbackDistance;
                const fallbackY = aiAircraft.y + Math.sin((aiAircraft.heading - 90) * Math.PI / 180) * fallbackDistance;

                const fallbackValidation = aiAircraft.calculateManeuverValidation(
                    Math.max(50, Math.min(CANVAS_WIDTH - 50, fallbackX)),
                    Math.max(50, Math.min(CANVAS_HEIGHT - 50, fallbackY)),
                    Math.max(ALTITUDE_MIN, Math.min(ALTITUDE_MAX, aiAircraft.altitude)),
                    aiAircraft.heading,
                    0
                );

                aiAircraft.lockOrders(
                    fallbackValidation.finalX,
                    fallbackValidation.finalY,
                    fallbackValidation.finalAltitude,
                    fallbackValidation.finalFlightHeading,
                    0
                );
            }
        }

        // Combat system
        function processCombat() {
            // Reset firing states and clear old hit warnings
            for (let plane of aircraft) {
                plane.isFiring = false;
                if (plane.firingCooldown > 0) plane.firingCooldown--;

                // Clear hit warning after 2 seconds
                if (plane.lastHitBy && (Date.now() - plane.lastHitTime) > 2000) {
                    plane.lastHitBy = null;
                }
            }

            // Check if aircraft can fire at each other
            for (let shooter of aircraft) {
                if (shooter.isDestroyed) continue; // Dead aircraft can't shoot
                if (shooter.ammunition <= 0) continue;
                if (shooter.firingCooldown > 0) continue;

                for (let target of aircraft) {
                    if (shooter === target) continue;
                    if (target.isDestroyed) continue; // Don't shoot at wreckage

                    // Calculate if target is in firing arc
                    const dx = target.x - shooter.x;
                    const dy = target.y - shooter.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Get shooter's FLIGHT heading (not nose heading which includes slip)
                    // During execution, the aircraft is flying in the direction of the path, not where nose points
                    let shooterFlightHeading = shooter.heading;

                    // If aircraft is using slip/skid, subtract it to get flight direction
                    if (shooter.slipAngle !== 0) {
                        shooterFlightHeading = (shooter.heading - shooter.slipAngle + 360) % 360;
                    }

                    const angleToTarget = (Math.atan2(dy, dx) * 180 / Math.PI + 90 + 360) % 360;
                    let angleDiff = angleToTarget - shooterFlightHeading;
                    if (angleDiff > 180) angleDiff -= 360;
                    if (angleDiff < -180) angleDiff += 360;
                    angleDiff = Math.abs(angleDiff);

                    // Firing cone: 20 degrees for realistic gunnery
                    if (angleDiff < 20 && distance < 400) {
                        // Check line of sight - clouds can block vision!
                        const losBlocked = !terrain.isLineOfSightClear(
                            shooter.x, shooter.y, shooter.altitude,
                            target.x, target.y, target.altitude
                        );

                        if (losBlocked) {
                            // Can't see target through clouds
                            shooter.timeOnTarget = 0;
                            continue;
                        }

                        // Target is in arc, range, and visible
                        const altitudeDiff = Math.abs(target.altitude - shooter.altitude);

                        // Calculate hit chance
                        let effectiveGunnerySkill = shooter.gunnerySkill * (1 - shooter.gForcePenalty);
                        let hitChance = effectiveGunnerySkill * 0.6;
                        hitChance *= Math.max(0.1, 1 - distance / 400); // Distance factor (max 400m)
                        hitChance *= Math.max(0.3, 1 - altitudeDiff / 500); // Altitude factor
                        hitChance *= Math.min(1, 0.2 + shooter.timeOnTarget / 8); // Time on target bonus

                        // Apply roll penalties
                        if (shooter.isRolling) {
                            // Very hard to aim while rolling (50% penalty)
                            hitChance *= 0.5;
                        }
                        if (target.isRolling) {
                            // Target harder to hit while rolling (30% penalty)
                            hitChance *= 0.7;
                        }

                        // Apply formation bonus (Enhancement #3)
                        if (squadron.inFormation && squadron.formationBonus > 0) {
                            // Check if shooter or wingmates are attacking same target
                            let coordinatedAttack = false;
                            if (shooter.squadron === squadron || target.squadron === squadron) {
                                coordinatedAttack = true;
                            }
                            if (coordinatedAttack) {
                                hitChance *= (1 + squadron.formationBonus);
                            }
                        }

                        shooter.timeOnTarget += 0.1;

                        // Fire if chance exceeds threshold and angle is good
                        if (hitChance >= shooter.fireThreshold && angleDiff < 15) {
                            shooter.isFiring = true;

                            // Handle mixed armament vs single weapon
                            if (shooter.hasMixedArmament) {
                                // Fire each weapon group independently with appropriate tactics
                                let totalDamage = 0;
                                let anyHit = false;
                                let weaponsFired = [];

                                for (let weaponGroup of shooter.weaponGroups) {
                                    if (weaponGroup.ammunition <= 0) continue;
                                    if (weaponGroup.firingCooldown > 0) {
                                        weaponGroup.firingCooldown--;
                                        continue;
                                    }

                                    // Tactical firing logic: Different weapons have different optimal ranges
                                    let shouldFireThisWeapon = false;

                                    if (weaponGroup.type === 'mg') {
                                        // MGs: Good at all ranges, use for ranging/suppression
                                        shouldFireThisWeapon = true; // Fire whenever in arc
                                    } else if (weaponGroup.type === 'hmg') {
                                        // HMGs: Effective at medium range, fairly common ammo
                                        shouldFireThisWeapon = distance < 350 || hitChance > 0.4;
                                    } else if (weaponGroup.type === 'cannon') {
                                        // Cannons: Save for close range where they're most effective
                                        // Calculate ammo percentage remaining
                                        const ammoPercent = weaponGroup.ammunition / weaponGroup.maxAmmunition;

                                        if (ammoPercent < 0.2) {
                                            // Critical ammo! Only fire at very close range with high hit chance
                                            shouldFireThisWeapon = distance < 150 && hitChance > 0.5;
                                        } else if (ammoPercent < 0.5) {
                                            // Low ammo, be conservative
                                            shouldFireThisWeapon = distance < 200 && hitChance > 0.4;
                                        } else {
                                            // Plenty of ammo, fire at close-medium range
                                            shouldFireThisWeapon = distance < 250;
                                        }
                                    }

                                    if (!shouldFireThisWeapon) continue;

                                    // Fire this weapon group
                                    weaponGroup.ammunition -= weaponGroup.ammoPerBurst;
                                    weaponGroup.firingCooldown = weaponGroup.rateOfFire;
                                    shooter.ammunition -= weaponGroup.ammoPerBurst; // Update total ammo
                                    weaponsFired.push(weaponGroup.name);

                                    // Play appropriate sound
                                    if (weaponGroup.sound === 'mg') {
                                        soundSpitfireMG.currentTime = 0;
                                        soundSpitfireMG.play().catch(e => console.log('Audio play failed:', e));
                                    } else if (weaponGroup.sound === 'hmg') {
                                        soundHMG.currentTime = 0;
                                        soundHMG.play().catch(e => console.log('Audio play failed:', e));
                                    } else if (weaponGroup.sound === 'cannon') {
                                        soundMe109Cannon.currentTime = 0;
                                        soundMe109Cannon.play().catch(e => console.log('Audio play failed:', e));
                                    }

                                    // Check if this weapon group hits
                                    if (Math.random() < hitChance) {
                                        let weaponDamage = weaponGroup.damageMin + Math.random() * (weaponGroup.damageMax - weaponGroup.damageMin);

                                        // Enhancement #8: Gun convergence accuracy bonus
                                        const convergenceDist = Math.abs(distance - shooter.gunConvergence);
                                        if (convergenceDist < 50) {
                                            weaponDamage *= 1.3;
                                        } else if (convergenceDist < 100) {
                                            weaponDamage *= 1.1;
                                        }

                                        totalDamage += weaponDamage;
                                        anyHit = true;
                                    }
                                }

                                if (weaponsFired.length > 0) {
                                    console.log(`${shooter.name} FIRING ${weaponsFired.join(' + ')} at ${target.name}! Distance: ${Math.round(distance)}m`);
                                }

                                if (anyHit) {
                                    // Apply combined damage from all weapon groups that hit
                                    let damageAmount = totalDamage;

                                    // Low durability aircraft take extra damage
                                    if (target.lowDurability) {
                                        damageAmount *= 1.4;
                                    }

                                    // Apply weather penalties
                                    if (weatherState.rainfall > 0) {
                                        damageAmount *= (1 - weatherState.rainfall * 0.3);
                                    }

                                    // Check for critical hit
                                    const critChance = calculateCriticalHitChance(shooter, target, distance, angleDiff);
                                    if (Math.random() < critChance) {
                                        const weaponType = totalDamage > 10 ? 'cannon' : 'mg';
                                        applyCriticalHit(target, weaponType);
                                        shooter.criticalHitsDealt++;
                                    }

                                    // Enhancement #4: Apply component damage
                                    applyComponentDamage(target, damageAmount);
                                    target.lastHitBy = shooter.name;
                                    target.lastHitTime = Date.now();
                                    console.log(`  HIT! Total damage: ${damageAmount.toFixed(1)} (${target.damage.toFixed(1)} total)`);

                                    // Add visual hit effects
                                    const hitType = totalDamage > 10 ? 'cannon' : 'mg';
                                    target.hitEffects.push({
                                        x: target.x,
                                        y: target.y,
                                        type: hitType,
                                        time: Date.now(),
                                        duration: hitType === 'cannon' ? 500 : 300
                                    });

                                    // Check for destruction
                                    if (target.damage >= 100 && !target.isDestroyed) {
                                        target.isDestroyed = true;
                                        console.log(`üí• ${target.name} DESTROYED by ${shooter.name}!`);
                                    }
                                } else if (weaponsFired.length > 0) {
                                    console.log(`  MISS!`);
                                }
                            } else {
                                // Single weapon type (legacy code)
                                shooter.ammunition -= shooter.ammoPerBurst;
                                shooter.firingCooldown = shooter.rateOfFire;

                                console.log(`${shooter.name} FIRING at ${target.name}! Distance: ${Math.round(distance)}m, Angle: ${angleDiff.toFixed(1)}¬∞, Hit chance: ${(hitChance * 100).toFixed(1)}%`);

                                // Play weapon sound
                                if (shooter.type === 'Spitfire') {
                                    soundSpitfireMG.currentTime = 0;
                                    soundSpitfireMG.play().catch(e => console.log('Audio play failed:', e));
                                } else {
                                    soundMe109Cannon.currentTime = 0;
                                    soundMe109Cannon.play().catch(e => console.log('Audio play failed:', e));
                                }

                                // Check if hit
                                if (Math.random() < hitChance) {
                                    let damageAmount = shooter.damagePerHit;

                                    // Enhancement #8: Gun convergence accuracy bonus
                                const convergenceDist = Math.abs(distance - shooter.gunConvergence);
                                if (convergenceDist < 50) {
                                    damageAmount *= 1.3; // Bonus damage at convergence range
                                } else if (convergenceDist < 100) {
                                    damageAmount *= 1.1;
                                }

                                // Low durability aircraft (like Zero) take extra damage
                                if (target.lowDurability) {
                                    damageAmount *= 1.4;
                                }

                                // Apply weather penalties
                                if (weatherState.rainfall > 0) {
                                    damageAmount *= (1 - weatherState.rainfall * 0.3);
                                }

                                // Check for critical hit
                                const critChance = calculateCriticalHitChance(shooter, target, distance, angleDiff);
                                if (Math.random() < critChance) {
                                    const weaponType = shooter.weaponType === 'cannon' ? 'cannon' : 'mg';
                                    applyCriticalHit(target, weaponType);
                                    shooter.criticalHitsDealt++;
                                }

                                // Enhancement #4: Apply component damage
                                applyComponentDamage(target, damageAmount);
                                target.lastHitBy = shooter.name;
                                target.lastHitTime = Date.now();
                                console.log(`  HIT! ${target.name} took ${damageAmount.toFixed(1)} damage (total: ${target.damage.toFixed(1)})`);

                                // Add visual hit effect based on weapon type
                                const hitType = shooter.type === 'Spitfire' ? 'mg' : 'cannon';
                                target.hitEffects.push({
                                    x: target.x + (Math.random() - 0.5) * 30,
                                    y: target.y + (Math.random() - 0.5) * 30,
                                    type: hitType,
                                    time: Date.now(),
                                    duration: hitType === 'cannon' ? 300 : 150 // Cannon effects last longer
                                });

                                // Play sound effect (when implemented)
                                // if (hitType === 'cannon') {
                                //     soundExplosion.currentTime = 0;
                                //     soundExplosion.play();
                                // } else {
                                //     soundHitMetal.currentTime = 0;
                                //     soundHitMetal.play();
                                // }

                                // Check for destruction
                                if (target.damage >= 100 && !target.isDestroyed) {
                                    target.isDestroyed = true;
                                    console.log(`üí• ${target.name} DESTROYED by ${shooter.name}!`);
                                }
                            } else {
                                console.log(`  MISS!`);
                            }
                        }
                    } else {
                        shooter.timeOnTarget = Math.max(0, shooter.timeOnTarget - 0.05);
                    }
                }
            }

            // Quick Win #3: AA Guns fire at aircraft
            for (let target of groundTargets) {
                if (target.isAAGun && !target.isDestroyed) {
                    const result = target.fireAtAircraft(aircraft);
                    if (result && result.hit) {
                        // AA gun hit an aircraft!
                        // Hit effect already handled in fireAtAircraft via applyComponentDamage
                    }
                }
            }
        }

        // Rendering
        function render() {
            ctx.fillStyle = '#3d5235';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Apply zoom and pan transform
            ctx.save();
            ctx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            ctx.translate(panX, panY); // Apply pan offset
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-CANVAS_WIDTH / 2, -CANVAS_HEIGHT / 2);

            // Render terrain
            terrain.render();

            // Render flight paths (dotted lines) for locked orders
            for (let plane of aircraft) {
                // Don't draw the path if this aircraft is currently being edited (has a ghost)
                if (plane === selectedAircraft && ghostAircraft) continue;

                if (plane.flightPath && plane.flightPath.length > 1 && plane.hasOrders) {
                    ctx.strokeStyle = plane.isPlayer ? '#00aaff' : '#ff6666';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]); // Dotted line

                    ctx.beginPath();
                    ctx.moveTo(plane.flightPath[0].x, plane.flightPath[0].y);
                    for (let i = 1; i < plane.flightPath.length; i++) {
                        ctx.lineTo(plane.flightPath[i].x, plane.flightPath[i].y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset to solid line
                }
            }

            // Render ghost aircraft flight path
            if (ghostAircraft && ghostAircraft.aircraft.flightPath && ghostAircraft.aircraft.flightPath.length > 1) {
                // Color based on validation state
                let pathColor = '#00ff00'; // valid = green
                if (ghostAircraft.state === 'stressful') pathColor = '#ffaa00'; // yellow
                if (ghostAircraft.state === 'illegal') pathColor = '#ff0000'; // red

                ctx.strokeStyle = pathColor;
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 4]); // Dotted line

                ctx.beginPath();
                ctx.moveTo(ghostAircraft.aircraft.flightPath[0].x, ghostAircraft.aircraft.flightPath[0].y);
                for (let i = 1; i < ghostAircraft.aircraft.flightPath.length; i++) {
                    ctx.lineTo(ghostAircraft.aircraft.flightPath[i].x, ghostAircraft.aircraft.flightPath[i].y);
                }
                ctx.stroke();
                ctx.setLineDash([]); // Reset to solid line
            }

            // Render aircraft
            for (let plane of aircraft) {
                plane.renderSVG();
            }

            // Render hit effects
            const now = Date.now();
            for (let plane of aircraft) {
                // Clean up old hit effects
                plane.hitEffects = plane.hitEffects.filter(effect => now - effect.time < effect.duration);

                // Render active hit effects
                for (let effect of plane.hitEffects) {
                    const age = now - effect.time;
                    const progress = age / effect.duration;
                    const alpha = 1 - progress; // Fade out over time

                    if (effect.type === 'cannon') {
                        // Autocannon hit - explosion effect
                        const size = 15 + (1 - progress) * 10; // Expands then fades

                        // Orange explosion core
                        ctx.fillStyle = `rgba(255, 150, 0, ${alpha * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, size * 0.6, 0, Math.PI * 2);
                        ctx.fill();

                        // Yellow outer glow
                        ctx.fillStyle = `rgba(255, 220, 100, ${alpha * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                        ctx.fill();

                        // Spark particles
                        for (let i = 0; i < 4; i++) {
                            const angle = (i / 4) * Math.PI * 2 + progress * Math.PI;
                            const dist = size * 1.5 * progress;
                            const sparkX = effect.x + Math.cos(angle) * dist;
                            const sparkY = effect.y + Math.sin(angle) * dist;

                            ctx.fillStyle = `rgba(255, 200, 50, ${alpha * 0.7})`;
                            ctx.beginPath();
                            ctx.arc(sparkX, sparkY, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else if (effect.type === 'critical') {
                        // Critical hit - larger explosion effect
                        const size = 20 + (1 - progress) * 15; // Larger than normal hits

                        // Draw larger explosion effect for critical hits
                        ctx.fillStyle = `rgba(255, 68, 0, ${alpha * 0.9})`;
                        ctx.strokeStyle = `rgba(255, 170, 0, ${alpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, size * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        // Draw radiating lines
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            ctx.strokeStyle = `rgba(255, 170, 0, ${alpha * 0.8})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(effect.x, effect.y);
                            ctx.lineTo(effect.x + Math.cos(angle) * size * 1.2, effect.y + Math.sin(angle) * size * 1.2);
                            ctx.stroke();
                        }

                        // Outer glow
                        ctx.fillStyle = `rgba(255, 200, 0, ${alpha * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, size * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Machine gun hit - bullet strike effect
                        const size = 8 + (1 - progress) * 5;

                        // White/yellow impact flash
                        ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, size * 0.5, 0, Math.PI * 2);
                        ctx.fill();

                        // Metal spark
                        ctx.fillStyle = `rgba(200, 200, 255, ${alpha * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, size, 0, Math.PI * 2);
                        ctx.fill();

                        // Small debris particles
                        for (let i = 0; i < 2; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = size * progress * 2;
                            const debrisX = effect.x + Math.cos(angle) * dist;
                            const debrisY = effect.y + Math.sin(angle) * dist;

                            ctx.fillStyle = `rgba(100, 100, 100, ${alpha * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(debrisX, debrisY, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            // Render gun fire effects (tracers and muzzle flash)
            for (let plane of aircraft) {
                if (plane.isFiring) {
                    // Muzzle flash
                    ctx.save();
                    ctx.translate(plane.x, plane.y);

                    // Get flight heading (not nose heading)
                    let flightHeading = plane.heading;
                    if (plane.slipAngle !== 0) {
                        flightHeading = (plane.heading - plane.slipAngle + 360) % 360;
                    }

                    ctx.rotate((flightHeading) * Math.PI / 180);

                    // Flash effect
                    ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(0, -35, 10, 0, Math.PI * 2);
                    ctx.fill();

                    // Tracer bullets - draw several short lines ahead
                    ctx.strokeStyle = 'rgba(255, 255, 100, 0.7)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 5; i++) {
                        const tracerStart = -40 - (i * 30);
                        const tracerEnd = tracerStart - 15;
                        ctx.beginPath();
                        ctx.moveTo(0, tracerStart);
                        ctx.lineTo(0, tracerEnd);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            // Render ground targets (Enhancement #6)
            for (let target of groundTargets) {
                target.render();
            }

            // Render ghost if in order mode
            if (ghostAircraft) {
                ghostAircraft.aircraft.renderSVG(true, ghostAircraft.state);
            }

            // Render predicted AI ghost (realistic mode)
            if (aiPredictedGhost) {
                // Temporarily modify me109's position to render the predicted ghost
                const savedX = me109.x;
                const savedY = me109.y;
                const savedAltitude = me109.altitude;
                const savedHeading = me109.heading;

                me109.x = aiPredictedGhost.x;
                me109.y = aiPredictedGhost.y;
                me109.altitude = aiPredictedGhost.altitude;
                me109.heading = aiPredictedGhost.heading;

                me109.renderSVG(true, 'valid'); // Render as ghost

                // Restore original position
                me109.x = savedX;
                me109.y = savedY;
                me109.altitude = savedAltitude;
                me109.heading = savedHeading;
            }

            ctx.restore();

            // Render weather effects (Enhancement #7) - after zoom/pan restore
            renderWeather();

            // Render minimap (Enhancement #12)
            renderMinimap();

            // Render energy diagram (Enhancement #9)
            renderEnergyDiagram();

            // Draw scale bar (in screen space, not affected by zoom/pan)
            const scaleBarLength = 100; // Represents 100 meters
            const scaleBarX = 20;
            const scaleBarY = CANVAS_HEIGHT - 40;

            ctx.strokeStyle = '#ffffff';
            ctx.fillStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.font = '14px Courier New';

            // Draw scale bar line
            ctx.beginPath();
            ctx.moveTo(scaleBarX, scaleBarY);
            ctx.lineTo(scaleBarX + scaleBarLength, scaleBarY);
            ctx.stroke();

            // Draw end caps
            ctx.beginPath();
            ctx.moveTo(scaleBarX, scaleBarY - 5);
            ctx.lineTo(scaleBarX, scaleBarY + 5);
            ctx.moveTo(scaleBarX + scaleBarLength, scaleBarY - 5);
            ctx.lineTo(scaleBarX + scaleBarLength, scaleBarY + 5);
            ctx.stroke();

            // Draw label
            ctx.fillText('100m', scaleBarX + scaleBarLength / 2 - 20, scaleBarY - 10);

            // Draw zoom level indicator
            ctx.fillStyle = '#aaaaaa';
            ctx.font = '12px Courier New';
            ctx.fillText(`Zoom: ${zoomLevel.toFixed(1)}x`, scaleBarX, scaleBarY + 20);
        }

        function updateUI() {
            // Update phase and turn
            let phaseText = gameState;
            if (hotSeatMode && gameState === 'ORDER') {
                phaseText = `PLAYER ${currentPlayer} ORDER`;
            }
            document.getElementById('currentPhase').textContent = phaseText;
            document.getElementById('currentTurn').textContent = currentTurn;

            document.getElementById('spitfireStats').innerHTML = spitfire.getStatsHTML();
            document.getElementById('me109Stats').innerHTML = me109.getStatsHTML();

            // Squadron status display
            if (squadron.leader && squadron.wingmen.length > 0) {
                document.getElementById('squadronStatus').style.display = 'block';
                document.getElementById('formationDisplay').textContent = `Formation: ${squadron.formation.replace('_', ' ').toUpperCase()}`;
                document.getElementById('wingmanCount').textContent = `Wingmen: ${squadron.wingmen.length}`;
                const bonusPercent = Math.round(squadron.formationBonus * 100);
                document.getElementById('formationBonusDisplay').textContent = squadron.inFormation ?
                    `Formation Bonus: +${bonusPercent}%` : 'Formation: BROKEN';
            } else {
                document.getElementById('squadronStatus').style.display = 'none';
            }

            // Show execute button logic
            let showExecute = false;
            if (gameState === 'ORDER' && !awaitingPlayerSwitch) {
                if (hotSeatMode) {
                    // In hot-seat, show execute only when both players have ordered
                    const allHaveOrders = aircraft.every(a => a.hasOrders || a.isDestroyed);
                    showExecute = allHaveOrders;
                } else {
                    // In single-player, show when all aircraft have orders
                    const allHaveOrders = aircraft.every(a => a.hasOrders);
                    showExecute = allHaveOrders;
                }
            }
            document.getElementById('executeButton').style.display = showExecute ? 'block' : 'none';
        }

        // Mouse handling
        let mouseX = 0;
        let mouseY = 0;
        let ghostRotation = 0;
        let ghostAltitudeOffset = 0;
        let ghostSlipAngle = 0; // Slip/skid angle in degrees (nose pointing different direction than movement)
        let zoomLevel = 1.0; // Zoom level for canvas (1.0 = no zoom)
        let panX = 0; // Pan offset X
        let panY = 0; // Pan offset Y
        let isPanning = false; // Middle mouse button panning active
        let lastPanX = 0; // Last pan mouse position
        let lastPanY = 0;

        // Helper function to transform screen coordinates to canvas coordinates (accounting for zoom and pan)
        function screenToCanvas(screenX, screenY) {
            // Screen coords relative to canvas element
            // Need to reverse the zoom and pan transformation:
            // 1. Translate to origin (center of canvas)
            // 2. Account for pan offset
            // 3. Divide by zoom (inverse of scale)
            // 4. Translate back
            const centerX = CANVAS_WIDTH / 2;
            const centerY = CANVAS_HEIGHT / 2;

            const canvasX = centerX + ((screenX - centerX) - panX) / zoomLevel;
            const canvasY = centerY + ((screenY - centerY) - panY) / zoomLevel;

            return { x: canvasX, y: canvasY };
        }

        // Helper function to update ghost aircraft position and validation
        function updateGhost() {
            if (!selectedAircraft || !ghostAircraft) return;

            // Target position (where mouse is pointing)
            const targetX = mouseX;
            const targetY = mouseY;
            const targetHeading = (selectedAircraft.heading + ghostRotation + 360) % 360;
            const targetAltitude = Math.max(ALTITUDE_MIN,
                Math.min(ALTITUDE_MAX, selectedAircraft.altitude + ghostAltitudeOffset));

            // Calculate realistic path from current position to target (with slip/skid angle)
            const validation = selectedAircraft.calculateManeuverValidation(
                targetX,
                targetY,
                targetAltitude,
                targetHeading,
                ghostSlipAngle
            );

            ghostAircraft.state = validation.state;
            ghostAircraft.validation = validation;

            // Copy the calculated flight path to the ghost aircraft for rendering
            ghostAircraft.aircraft.flightPath = selectedAircraft.flightPath;

            // Position ghost at the END of the calculated path (where aircraft will actually end up)
            if (selectedAircraft.flightPath && selectedAircraft.flightPath.length > 0) {
                const finalState = selectedAircraft.flightPath[selectedAircraft.flightPath.length - 1];
                ghostAircraft.aircraft.x = finalState.x;
                ghostAircraft.aircraft.y = finalState.y;
                ghostAircraft.aircraft.altitude = finalState.altitude;
                // Apply slip/skid angle to final heading (nose points different direction than movement)
                ghostAircraft.aircraft.heading = (finalState.heading + ghostSlipAngle + 360) % 360;
            } else {
                // Fallback if no path calculated
                ghostAircraft.aircraft.x = targetX;
                ghostAircraft.aircraft.y = targetY;
                ghostAircraft.aircraft.altitude = targetAltitude;
                ghostAircraft.aircraft.heading = (targetHeading + ghostSlipAngle + 360) % 360;
            }
        }

        // Helper function to update ghost panel
        function updateGhostPanel() {
            if (!ghostAircraft || !ghostAircraft.validation) return;

            const panel = document.getElementById('ghostPanel');
            panel.style.display = 'block';
            // Position panel further from mouse to avoid obscuring ghost aircraft
            panel.style.left = (lastScreenX + 150) + 'px';
            panel.style.top = (lastScreenY + 20) + 'px';

            const validation = ghostAircraft.validation;
            const throttlePercent = Math.round(selectedAircraft.throttle * 100);
            const altChange = Math.round(validation.targetAltitude - selectedAircraft.altitude);
            const altChangeSymbol = altChange > 0 ? '‚Üë' : altChange < 0 ? '‚Üì' : '‚Üí';
            const rollDisplay = selectedAircraft.rollType === 'none' ? 'None' :
                               selectedAircraft.rollType === 'half' ? 'Half Roll (Inverted)' :
                               'Full Roll';
            const rollColor = selectedAircraft.rollType !== 'none' ? '#ffaa00' : '#ffffff';
            const fireThresholdPercent = Math.round(selectedAircraft.fireThreshold * 100);
            const fireThresholdColor = selectedAircraft.fireThreshold < 0.20 ? '#ff4444' :
                                      selectedAircraft.fireThreshold < 0.30 ? '#ffaa00' : '#00ff00';
            let panelHTML = `
                <div>Throttle: ${throttlePercent}%</div>
                <div>Heading: ${validation.targetHeading}¬∞</div>
                <div>Slip: ${ghostSlipAngle}¬∞ ${ghostSlipAngle > 0 ? '‚Üí' : ghostSlipAngle < 0 ? '‚Üê' : ''}</div>
                <div>Altitude: ${validation.targetAltitude}m (${altChange >= 0 ? '+' : ''}${altChange}m ${altChangeSymbol})</div>
                <div>Speed: ${validation.targetSpeed} m/s</div>
                <div>G-Force: ${validation.gForce}G</div>
                <div style="color: ${rollColor}">Roll: ${rollDisplay}</div>
                <div style="color: ${fireThresholdColor}">Fire Threshold: ${fireThresholdPercent}%</div>
            `;

            if (validation.warnings.length > 0) {
                panelHTML += '<div style="color: #ff4444; margin-top: 5px;">';
                for (let warning of validation.warnings) {
                    panelHTML += `<div>${warning}</div>`;
                }
                panelHTML += '</div>';
            }

            panel.innerHTML = panelHTML;
        }

        let lastScreenX = 0;
        let lastScreenY = 0;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            lastScreenX = e.clientX - rect.left;
            lastScreenY = e.clientY - rect.top;

            // Handle middle mouse button panning
            if (isPanning) {
                const deltaX = lastScreenX - lastPanX;
                const deltaY = lastScreenY - lastPanY;
                panX += deltaX;
                panY += deltaY;
                lastPanX = lastScreenX;
                lastPanY = lastScreenY;
            }

            // Transform to canvas coordinates
            const canvasCoords = screenToCanvas(lastScreenX, lastScreenY);
            mouseX = canvasCoords.x;
            mouseY = canvasCoords.y;

            if (selectedAircraft && ghostAircraft) {
                updateGhost();
                updateGhostPanel();
            }
        });

        // Middle mouse button down - start panning
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1) { // Middle mouse button
                e.preventDefault();
                isPanning = true;
                const rect = canvas.getBoundingClientRect();
                lastPanX = e.clientX - rect.left;
                lastPanY = e.clientY - rect.top;
                canvas.style.cursor = 'grabbing';
            }
        });

        // Mouse up - stop panning
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 1) { // Middle mouse button
                isPanning = false;
                canvas.style.cursor = 'default';
            }
        });

        // Mouse leave - stop panning if active
        canvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('click', (e) => {
            if (gameState !== 'ORDER') return;

            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;

            // Transform to canvas coordinates
            const canvasCoords = screenToCanvas(screenX, screenY);
            const clickX = canvasCoords.x;
            const clickY = canvasCoords.y;

            console.log('Click at:', clickX, clickY, 'Ghost active:', !!ghostAircraft, 'State:', ghostAircraft?.state);

            // Check if clicking on an aircraft
            for (let plane of aircraft) {
                if (plane.isClicked(clickX, clickY)) {
                    console.log('Clicked on aircraft:', plane.name);

                    // Hot-seat mode: check if current player can control this aircraft
                    if (!canPlayerControlAircraft(plane)) {
                        console.log('Cannot control opponent aircraft in hot-seat mode');
                        continue;
                    }
                    if (plane.isDestroyed) continue; // Can't control destroyed aircraft

                    if (selectedAircraft === plane) {
                        console.log('Same aircraft - attempting to lock');
                        // Lock in orders (using final flight heading from validation, not nose heading)
                        if (ghostAircraft && ghostAircraft.state !== 'illegal' && ghostAircraft.validation) {
                            console.log('Locking orders!');
                            const val = ghostAircraft.validation;
                            plane.lockOrders(
                                val.finalX,
                                val.finalY,
                                val.finalAltitude,
                                val.finalFlightHeading,
                                ghostSlipAngle // Save slip angle for nose direction during execution
                            );
                            selectedAircraft = null; // Deselect but keep ghost visible
                            ghostRotation = 0;
                            ghostAltitudeOffset = 0;
                            ghostSlipAngle = 0;
                            document.getElementById('ghostPanel').style.display = 'none';

                            // Hot-seat mode: check if we need to switch players
                            if (hotSeatMode) {
                                checkHotSeatOrdersComplete();
                            } else {
                                // Generate AI orders for all AI aircraft (single player only)
                                for (let aiPlane of aircraft) {
                                    if (!aiPlane.isPlayer && !aiPlane.isDestroyed) {
                                        generateAIOrders(aiPlane);
                                    }
                                }
                            }
                        } else {
                            console.log('Ghost illegal, not locking');
                        }
                    } else if (plane.hasOrders) {
                        console.log('Unlocking orders');
                        // Unlock orders - but recreate ghost at unlocked position
                        plane.unlockOrders();
                        selectedAircraft = plane;
                        ghostAircraft = {
                            aircraft: new Aircraft(plane.name, plane.type, plane.targetX, plane.targetY,
                                plane.targetAltitude, plane.targetHeading, plane.isPlayer),
                            state: 'valid'
                        };
                        ghostRotation = 0;
                        ghostAltitudeOffset = 0;
                        ghostSlipAngle = 0;
                        updateGhost();
                    } else {
                        console.log('Selecting aircraft');
                        // Select aircraft
                        selectedAircraft = plane;
                        ghostAircraft = {
                            aircraft: new Aircraft(plane.name, plane.type, plane.x, plane.y,
                                plane.altitude, plane.heading, plane.isPlayer),
                            state: 'valid'
                        };
                        ghostRotation = 0;
                        ghostAltitudeOffset = 0;
                        ghostSlipAngle = 0;
                        updateGhost(); // Update ghost immediately
                    }
                    return;
                }
            }

            console.log('Click did not hit aircraft - attempting to lock from anywhere');
            // If we didn't click on any aircraft, but we have a ghost selected, lock in orders
            if (selectedAircraft && ghostAircraft && ghostAircraft.state !== 'illegal' && ghostAircraft.validation) {
                console.log('Locking orders from empty click!');
                const val = ghostAircraft.validation;
                selectedAircraft.lockOrders(
                    val.finalX,
                    val.finalY,
                    val.finalAltitude,
                    val.finalFlightHeading,
                    ghostSlipAngle // Save slip angle for nose direction during execution
                );
                selectedAircraft = null; // Deselect but keep ghost visible
                ghostRotation = 0;
                ghostAltitudeOffset = 0;
                ghostSlipAngle = 0;
                document.getElementById('ghostPanel').style.display = 'none';

                // Generate AI orders for all AI aircraft
                for (let aiPlane of aircraft) {
                    if (!aiPlane.isPlayer && !aiPlane.isDestroyed) {
                        generateAIOrders(aiPlane);
                    }
                }
            } else {
                console.log('Cannot lock:', {
                    selectedAircraft: !!selectedAircraft,
                    ghostAircraft: !!ghostAircraft,
                    state: ghostAircraft?.state
                });
            }
        });

        // Keyboard handling
        window.addEventListener('keydown', (e) => {
            // Prevent key repeat from causing multiple rapid changes
            if (e.repeat) return;

            // Wingman commands (work anytime)
            if (squadron.leader && squadron.wingmen.length > 0) {
                switch(e.key) {
                    case '1':
                        issueWingmanCommand('attack_my_target');
                        return;
                    case '2':
                        issueWingmanCommand('cover_me');
                        return;
                    case '3':
                        issueWingmanCommand('break_attack');
                        return;
                    case '4':
                        issueWingmanCommand('rejoin');
                        return;
                    case '5':
                        issueWingmanCommand('free_hunt');
                        return;
                    case 'f':
                    case 'F':
                        // Cycle through formations
                        const formationTypes = Object.keys(formations);
                        const currentIndex = formationTypes.indexOf(squadron.formation);
                        const nextIndex = (currentIndex + 1) % formationTypes.length;
                        changeFormation(formationTypes[nextIndex]);
                        return;
                }
            }

            if (!selectedAircraft || !ghostAircraft) return;

            switch(e.key.toLowerCase()) {
                case 'w':
                    // Increase throttle
                    selectedAircraft.throttle = Math.min(1.0, selectedAircraft.throttle + 0.1);
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 's':
                    // Reduce throttle
                    selectedAircraft.throttle = Math.max(0.0, selectedAircraft.throttle - 0.1);
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'q':
                    // Decrease altitude (dive)
                    ghostAltitudeOffset -= 50;
                    // Limit to max dive rate over current turn time
                    const maxDive = -selectedAircraft.maxDiveRate * turnTime;
                    ghostAltitudeOffset = Math.max(maxDive, ghostAltitudeOffset);
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'e':
                    // Increase altitude (climb)
                    ghostAltitudeOffset += 50;
                    // Limit to max climb rate over current turn time
                    const maxClimb = selectedAircraft.maxClimbRate * turnTime;
                    ghostAltitudeOffset = Math.min(maxClimb, ghostAltitudeOffset);
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'a':
                    // Slip/skid left (nose points left of direction of travel)
                    ghostSlipAngle = Math.max(-30, ghostSlipAngle - 5);
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'd':
                    // Slip/skid right (nose points right of direction of travel)
                    ghostSlipAngle = Math.min(30, ghostSlipAngle + 5);
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'r':
                    // Cycle roll type: none -> half -> full -> none
                    if (selectedAircraft.rollType === 'none') {
                        selectedAircraft.rollType = 'half';
                    } else if (selectedAircraft.rollType === 'half') {
                        selectedAircraft.rollType = 'full';
                    } else {
                        selectedAircraft.rollType = 'none';
                    }
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'i':
                    // Toggle Immelmann turn
                    selectedAircraft.maneuverType = selectedAircraft.maneuverType === 'immelmann' ? 'none' : 'immelmann';
                    if (selectedAircraft.maneuverType === 'immelmann') {
                        selectedAircraft.rollType = 'none'; // Clear roll
                    }
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 't':
                    // Toggle Split-S
                    selectedAircraft.maneuverType = selectedAircraft.maneuverType === 'split-s' ? 'none' : 'split-s';
                    if (selectedAircraft.maneuverType === 'split-s') {
                        selectedAircraft.rollType = 'none'; // Clear roll
                    }
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'l':
                    // Toggle Loop
                    selectedAircraft.maneuverType = selectedAircraft.maneuverType === 'loop' ? 'none' : 'loop';
                    if (selectedAircraft.maneuverType === 'loop') {
                        selectedAircraft.rollType = 'none'; // Clear roll
                    }
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'h':
                    // Toggle Half-loop
                    selectedAircraft.maneuverType = selectedAircraft.maneuverType === 'half-loop' ? 'none' : 'half-loop';
                    if (selectedAircraft.maneuverType === 'half-loop') {
                        selectedAircraft.rollType = 'none'; // Clear roll
                    }
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'z':
                    // Decrease fire threshold (fire more aggressively, less accurate)
                    selectedAircraft.fireThreshold = Math.max(0.05, selectedAircraft.fireThreshold - 0.05);
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'x':
                    // Increase fire threshold (fire more conservatively, wait for better shots)
                    selectedAircraft.fireThreshold = Math.min(0.80, selectedAircraft.fireThreshold + 0.05);
                    updateGhost();
                    updateGhostPanel();
                    break;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            // Always zoom in/out with mouse wheel
            if (e.deltaY < 0) {
                zoomLevel = Math.min(3.0, zoomLevel * 1.1); // Max 3x zoom
            } else {
                zoomLevel = Math.max(0.5, zoomLevel / 1.1); // Min 0.5x zoom
            }
        });

        // Execute button
        document.getElementById('executeButton').addEventListener('click', () => {
            gameState = 'EXECUTION';
            executionStartTime = Date.now();
            executionRecording = [];

            // Clear ghost and selection when execution starts
            ghostAircraft = null;
            selectedAircraft = null;
            document.getElementById('ghostPanel').style.display = 'none';

            updateUI();
        });

        document.getElementById('replayButton').addEventListener('click', () => {
            // Replay execution
            gameState = 'EXECUTION';
            executionStartTime = Date.now();
            document.getElementById('replayButton').style.display = 'none';
            document.getElementById('nextPhase2s').style.display = 'none';
            document.getElementById('nextPhase4s').style.display = 'none';
            document.getElementById('nextPhase6s').style.display = 'none';
            document.getElementById('nextPhase8s').style.display = 'none';

            // Reset aircraft to start of turn positions
            for (let plane of aircraft) {
                plane.x = plane.startX;
                plane.y = plane.startY;
                plane.altitude = plane.startAltitude;
                plane.heading = plane.startHeading;
                plane.speed = plane.startSpeed;
                plane.hasOrders = true;
            }
        });

        // Helper function for next phase transition with variable duration
        function startNextPhase(duration) {
            // Set the turn duration for next phase
            turnTime = duration;
            executionTime = duration * 1000; // Convert to milliseconds

            gameState = 'ORDER';
            currentTurn++;

            // Handle stall recovery/loss of control for next turn
            for (let plane of aircraft) {
                if (plane.inStall) {
                    // Aircraft stalled - lose control this turn (AI takes over recovery)
                    console.log(`${plane.name} is recovering from stall!`);

                    // Auto-generate recovery maneuver: nose down, gain speed
                    const recoveryX = plane.x + Math.cos((plane.heading - 90) * Math.PI / 180) * 200;
                    const recoveryY = plane.y + Math.sin((plane.heading - 90) * Math.PI / 180) * 200;
                    const recoveryAltitude = Math.max(100, plane.altitude - 100); // Lose 100m altitude
                    const recoveryHeading = plane.heading; // Maintain heading during recovery

                    const recoveryValidation = plane.calculateManeuverValidation(recoveryX, recoveryY, recoveryAltitude, recoveryHeading);
                    plane.lockOrders(
                        recoveryValidation.finalX,
                        recoveryValidation.finalY,
                        recoveryValidation.finalAltitude,
                        recoveryValidation.finalFlightHeading,
                        0
                    );
                    plane.inStall = false; // Clear stall for next turn
                    plane.damage += 5; // Damage from stall
                }
            }

            // Hide all phase buttons
            document.getElementById('replayButton').style.display = 'none';
            document.getElementById('nextPhase2s').style.display = 'none';
            document.getElementById('nextPhase4s').style.display = 'none';
            document.getElementById('nextPhase6s').style.display = 'none';
            document.getElementById('nextPhase8s').style.display = 'none';
            updateUI();
        }

        // Event listeners for next phase buttons (2s, 4s, 6s, 8s)
        document.getElementById('nextPhase2s').addEventListener('click', () => startNextPhase(2));
        document.getElementById('nextPhase4s').addEventListener('click', () => startNextPhase(4));
        document.getElementById('nextPhase6s').addEventListener('click', () => startNextPhase(6));
        document.getElementById('nextPhase8s').addEventListener('click', () => startNextPhase(8));

        document.getElementById('realisticModeCheckbox').addEventListener('change', (e) => {
            realisticMode = e.target.checked;
            console.log('Realistic AI Display:', realisticMode ? 'ON' : 'OFF');
            // Clear any existing prediction when toggling
            if (!realisticMode) {
                aiPredictedGhost = null;
            }
        });

        // Main game loop
        function gameLoop() {
            // Manage engine sounds based on game state and aircraft status
            if (gameState === 'EXECUTION') {
                if (!spitfire.isDestroyed && soundSpitfireEngine.paused) {
                    soundSpitfireEngine.play().catch(e => console.log('Engine audio failed:', e));
                }
                if (!me109.isDestroyed && soundMe109Engine.paused) {
                    soundMe109Engine.play().catch(e => console.log('Engine audio failed:', e));
                }
            } else {
                if (!soundSpitfireEngine.paused) soundSpitfireEngine.pause();
                if (!soundMe109Engine.paused) soundMe109Engine.pause();
            }

            // Stop engine sounds for destroyed aircraft
            if (spitfire.isDestroyed && !soundSpitfireEngine.paused) {
                soundSpitfireEngine.pause();
            }
            if (me109.isDestroyed && !soundMe109Engine.paused) {
                soundMe109Engine.pause();
            }

            if (gameState === 'EXECUTION') {
                const elapsed = Date.now() - executionStartTime;
                const progress = Math.min(1, elapsed / executionTime);

                // Move aircraft
                for (let plane of aircraft) {
                    if (plane.hasOrders) {
                        plane.executeOrders(progress);
                    }
                }

                // Process combat
                processCombat();

                // Check for game over
                let player1Destroyed = false;
                let player2Destroyed = false;

                if (hotSeatMode) {
                    player1Destroyed = player1Aircraft.every(a => a.isDestroyed);
                    player2Destroyed = player2Aircraft.every(a => a.isDestroyed);
                } else {
                    player1Destroyed = spitfire.isDestroyed;
                    player2Destroyed = me109.isDestroyed;
                }

                if (player1Destroyed || player2Destroyed) {
                    gameState = 'GAMEOVER';
                }

                if (progress >= 1 && gameState !== 'GAMEOVER') {
                    // Finalize execution
                    for (let plane of aircraft) {
                        plane.finalizeExecution();
                    }
                    gameState = 'REVIEW';

                    // Reset hot-seat mode for next turn
                    if (hotSeatMode) {
                        currentPlayer = 1;
                    }

                    document.getElementById('replayButton').style.display = 'block';
                    document.getElementById('nextPhase2s').style.display = 'block';
                    document.getElementById('nextPhase4s').style.display = 'block';
                    document.getElementById('nextPhase6s').style.display = 'block';
                    document.getElementById('nextPhase8s').style.display = 'block';
                }
            }

            // Game over screen
            if (gameState === 'GAMEOVER') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Courier New';
                ctx.textAlign = 'center';

                if (hotSeatMode) {
                    // Hot-seat victory message
                    const player1Lost = player1Aircraft.every(a => a.isDestroyed);
                    if (player1Lost) {
                        ctx.fillStyle = '#00ff00';
                        ctx.fillText('PLAYER 2 WINS!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
                        ctx.font = '24px Courier New';
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText('Player 1 aircraft destroyed', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                    } else {
                        ctx.fillStyle = '#00ff00';
                        ctx.fillText('PLAYER 1 WINS!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
                        ctx.font = '24px Courier New';
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText('Player 2 aircraft destroyed', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                    }
                } else {
                    // Single-player victory message
                    if (spitfire.isDestroyed) {
                        ctx.fillStyle = '#ff4444';
                        ctx.fillText('DEFEAT', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
                        ctx.font = '24px Courier New';
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(`Your Spitfire was destroyed by ${spitfire.lastHitBy}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                    } else if (me109.isDestroyed) {
                        ctx.fillStyle = '#00ff00';
                        ctx.fillText('VICTORY!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
                        ctx.font = '24px Courier New';
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText('Enemy Me-109 destroyed!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                    }
                }

                ctx.font = '18px Courier New';
                ctx.fillStyle = '#aaaaaa';
                ctx.fillText('Press RESTART to play again', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 80);
                ctx.textAlign = 'left';
            }

            render();
            updateUI();
            if (!isPaused) {
                requestAnimationFrame(gameLoop);
            }
        }

        // Enhancement #11: Game Flow Functions
        function restartGame() {
            // Reset all game state
            gameState = 'ORDER';
            currentTurn = 1;
            isPaused = false;
            selectedAircraft = null;
            ghostAircraft = null;
            executionRecording = [];
            groundTargets = [];

            // Reset hot-seat multiplayer state
            hotSeatMode = false;
            currentPlayer = 1;
            player1Aircraft = [];
            player2Aircraft = [];
            awaitingPlayerSwitch = false;

            // Reinitialize aircraft
            spitfire = new Aircraft('Player', 'Spitfire', 400, 500, 500, 90, true);
            me109 = new Aircraft('Enemy', 'Me-109', 1400, 500, 500, 270, false);
            aircraft = [spitfire, me109];

            // Reset terrain
            terrain = new Terrain();

            // Apply weather
            applyWeather(gameSettings.weather);

            // Update UI
            updateUI();
        }

        function togglePause() {
            if (gameState === 'EXECUTION') {
                if (!isPaused) {
                    isPaused = true;
                    pausedTime = Date.now() - executionStartTime;
                    document.getElementById('pauseButton').textContent = 'RESUME';
                } else {
                    isPaused = false;
                    executionStartTime = Date.now() - pausedTime;
                    document.getElementById('pauseButton').textContent = 'PAUSE';
                    requestAnimationFrame(gameLoop);
                }
            }
        }

        function openSettings() {
            document.getElementById('settingsPanel').style.display = 'block';
        }

        function closeSettings() {
            document.getElementById('settingsPanel').style.display = 'none';

            // Apply settings
            gameSettings.gameMode = document.getElementById('gameModeSelect').value;
            gameSettings.difficulty = document.getElementById('difficultySelect').value;
            gameSettings.weather = document.getElementById('weatherSelect').value;
            gameSettings.volume = document.getElementById('volumeSlider').value / 100;

            // Update sound volumes
            soundSpitfireEngine.volume = gameSettings.volume * 0.3;
            soundMe109Engine.volume = gameSettings.volume * 0.3;
            soundSpitfireMG.volume = gameSettings.volume * 0.6;
            soundHMG.volume = gameSettings.volume * 0.65;
            soundMe109Cannon.volume = gameSettings.volume * 0.7;

            // Apply game mode settings
            if (gameSettings.gameMode === 'realistic' || gameSettings.gameMode === 'simulation') {
                gameSettings.enableFuel = true;
                gameSettings.enableComponentDamage = true;
            } else {
                gameSettings.enableFuel = false;
                gameSettings.enableComponentDamage = gameSettings.gameMode !== 'arcade';
            }

            // Apply weather
            applyWeather(gameSettings.weather);

            // Apply multiplayer setting
            const multiplayerMode = document.getElementById('multiplayerSelect').value;
            if (multiplayerMode === 'hotseat' && !hotSeatMode) {
                enableHotSeatMode();
            } else if (multiplayerMode === 'single' && hotSeatMode) {
                // Disable hot-seat mode
                hotSeatMode = false;
                currentPlayer = 1;
                // Restore AI control to player2 aircraft
                for (let plane of player2Aircraft) {
                    plane.isPlayer = false;
                    plane.hotSeatPlayer = undefined;
                }
                player1Aircraft = [];
                player2Aircraft = [];
                updateUI();
            }
        }

        // Enhancement #7: Weather System
        function applyWeather(weather) {
            switch (weather) {
                case 'clear':
                    weatherState.windSpeed = 0;
                    weatherState.rainfall = 0;
                    weatherState.visibility = 1.0;
                    break;
                case 'wind':
                    weatherState.windSpeed = 10 + Math.random() * 15; // 10-25 m/s
                    weatherState.windDirection = Math.random() * 360;
                    weatherState.rainfall = 0;
                    weatherState.visibility = 1.0;
                    break;
                case 'rain':
                    weatherState.windSpeed = 5 + Math.random() * 10;
                    weatherState.windDirection = Math.random() * 360;
                    weatherState.rainfall = 0.5;
                    weatherState.visibility = 0.7;
                    break;
                case 'storm':
                    weatherState.windSpeed = 20 + Math.random() * 20; // 20-40 m/s
                    weatherState.windDirection = Math.random() * 360;
                    weatherState.rainfall = 1.0;
                    weatherState.visibility = 0.4;
                    break;
            }
        }

        function renderWeather() {
            if (weatherState.rainfall > 0) {
                ctx.save();
                ctx.globalAlpha = weatherState.rainfall * 0.3;
                ctx.strokeStyle = '#aaccff';
                ctx.lineWidth = 1;

                for (let i = 0; i < 100 * weatherState.rainfall; i++) {
                    const x = Math.random() * CANVAS_WIDTH;
                    const y = Math.random() * CANVAS_HEIGHT;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - 2, y + 15);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        // Enhancement #12: Minimap
        function renderMinimap() {
            const mmWidth = 200;
            const mmHeight = 200;
            const scaleX = mmWidth / CANVAS_WIDTH;
            const scaleY = mmHeight / CANVAS_HEIGHT;

            // Clear minimap
            minimapCtx.fillStyle = 'rgba(20, 30, 20, 0.9)';
            minimapCtx.fillRect(0, 0, mmWidth, mmHeight);

            // Draw terrain (simplified)
            minimapCtx.fillStyle = 'rgba(100, 80, 60, 0.5)';
            for (let mountain of terrain.mountains) {
                minimapCtx.beginPath();
                minimapCtx.arc(mountain.x * scaleX, mountain.y * scaleY, 5, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            // Draw clouds
            minimapCtx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            for (let cloud of terrain.clouds) {
                minimapCtx.beginPath();
                minimapCtx.arc(cloud.x * scaleX, cloud.y * scaleY, 8, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            // Draw ground targets
            minimapCtx.fillStyle = 'rgba(200, 150, 100, 0.8)';
            for (let target of groundTargets) {
                if (!target.isDestroyed) {
                    minimapCtx.fillRect(target.x * scaleX - 2, target.y * scaleY - 2, 4, 4);
                }
            }

            // Draw aircraft
            for (let plane of aircraft) {
                if (!plane.isDestroyed) {
                    minimapCtx.fillStyle = plane.isPlayer ? '#00ffff' : '#ff0000';
                    minimapCtx.beginPath();
                    minimapCtx.arc(plane.x * scaleX, plane.y * scaleY, 3, 0, Math.PI * 2);
                    minimapCtx.fill();

                    // Direction indicator
                    const headingRad = (plane.heading - 90) * Math.PI / 180;
                    minimapCtx.strokeStyle = minimapCtx.fillStyle;
                    minimapCtx.lineWidth = 2;
                    minimapCtx.beginPath();
                    minimapCtx.moveTo(plane.x * scaleX, plane.y * scaleY);
                    minimapCtx.lineTo(
                        plane.x * scaleX + Math.cos(headingRad) * 8,
                        plane.y * scaleY + Math.sin(headingRad) * 8
                    );
                    minimapCtx.stroke();
                }
            }

            // Border
            minimapCtx.strokeStyle = '#0f3460';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(0, 0, mmWidth, mmHeight);
        }

        // Enhancement #5: Bailout Mechanics
        function attemptBailout(aircraft) {
            if (!aircraft.canBailout || aircraft.isDestroyed || aircraft.pilotBailedOut) {
                return false;
            }

            // Can only bailout if damage > 60% or fuel critical
            if (aircraft.damage > 60 || (gameSettings.enableFuel && aircraft.fuel < 10)) {
                aircraft.pilotBailedOut = true;
                aircraft.canBailout = false;

                // Create bailout visual effect
                const parachuteX = aircraft.x;
                const parachuteY = aircraft.y;
                const parachuteAlt = aircraft.altitude;

                // In friendly territory = rescued, in enemy territory = captured
                const isFriendlyTerritory = aircraft.isPlayer ? aircraft.x < CANVAS_WIDTH / 2 : aircraft.x > CANVAS_WIDTH / 2;

                setTimeout(() => {
                    alert(`${aircraft.name} pilot bailed out! ${isFriendlyTerritory ? 'Pilot rescued!' : 'Pilot captured.'}`);
                }, 1000);

                return true;
            }
            return false;
        }

        // Enhancement #4: Apply Component Damage
        function applyComponentDamage(aircraft, damage) {
            if (!gameSettings.enableComponentDamage) {
                aircraft.damage += damage;
                return;
            }

            // Randomly hit different components
            const component = ['engine', 'wings', 'tail', 'cockpit', 'fuelTank', 'leftWing', 'rightWing'][Math.floor(Math.random() * 7)];
            aircraft.componentDamage[component] += damage;

            // Engine damage reduces max speed and acceleration
            if (component === 'engine') {
                aircraft.maxSpeed *= 0.95;
                aircraft.maxAcceleration *= 0.9;
            }

            // Wing damage affects turn rate
            if (component === 'leftWing') {
                aircraft.asymmetricDamage.left += damage;
                aircraft.maxTurnRate *= 0.95;
            } else if (component === 'rightWing') {
                aircraft.asymmetricDamage.right += damage;
                aircraft.maxTurnRate *= 0.95;
            }

            // Tail damage affects stability
            if (component === 'tail') {
                aircraft.maxClimbRate *= 0.9;
            }

            // Cockpit damage can wound pilot
            if (component === 'cockpit' && Math.random() < 0.3) {
                aircraft.pilotWounded = true;
                aircraft.pilotSkill *= 0.7;
                aircraft.gunnerySkill *= 0.7;
            }

            // Fuel tank damage creates leak
            if (component === 'fuelTank') {
                aircraft.fuelLeak = true;
            }

            // Update overall damage
            aircraft.damage = Math.max(
                aircraft.componentDamage.engine,
                aircraft.componentDamage.wings,
                aircraft.componentDamage.tail,
                aircraft.componentDamage.cockpit,
                aircraft.componentDamage.fuelTank,
                aircraft.componentDamage.leftWing + aircraft.componentDamage.rightWing
            );
        }

        // Enhancement #9: Energy Management UI
        function renderEnergyDiagram() {
            const canvas = document.getElementById('energyDiagram');
            const ctx = canvas.getContext('2d');
            const width = 200;
            const height = 200;

            // Clear
            ctx.fillStyle = 'rgba(20, 30, 20, 0.9)';
            ctx.fillRect(0, 0, width, height);

            // Title
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 12px Courier New';
            ctx.fillText('Energy State', 10, 20);

            if (aircraft.length < 2) return;

            // Calculate energy states (specific energy = altitude + v¬≤/2g)
            const g = 9.81;
            const playerEnergy = spitfire.altitude + (spitfire.speed * spitfire.speed) / (2 * g);
            const enemyEnergy = me109.altitude + (me109.speed * me109.speed) / (2 * g);

            const maxEnergy = Math.max(playerEnergy, enemyEnergy, 1500);
            const playerBarHeight = (playerEnergy / maxEnergy) * 120;
            const enemyBarHeight = (enemyEnergy / maxEnergy) * 120;

            // Player energy bar
            ctx.fillStyle = '#0099ff';
            ctx.fillRect(30, 170 - playerBarHeight, 60, playerBarHeight);
            ctx.strokeStyle = '#ffffff';
            ctx.strokeRect(30, 50, 60, 120);
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Courier New';
            ctx.fillText('You', 45, 185);

            // Enemy energy bar
            ctx.fillStyle = '#ff4444';
            ctx.fillRect(110, 170 - enemyBarHeight, 60, enemyBarHeight);
            ctx.strokeRect(110, 50, 60, 120);
            ctx.fillText('Enemy', 120, 185);

            // Energy advantage indicator
            const advantage = playerEnergy - enemyEnergy;
            ctx.fillStyle = advantage > 0 ? '#00ff00' : '#ff4444';
            ctx.font = 'bold 14px Courier New';
            const advantageText = advantage > 0 ? `+${Math.round(advantage)}m` : `${Math.round(advantage)}m`;
            ctx.fillText(advantageText, 70, 40);

            // Engagement envelope (optimal attack zone)
            ctx.strokeStyle = '#ffaa00';
            ctx.setLineDash([3, 3]);
            ctx.strokeRect(30, 90, 140, 40);
            ctx.setLineDash([]);
            ctx.fillStyle = '#ffaa00';
            ctx.font = '9px Courier New';
            ctx.fillText('Optimal Zone', 55, 115);

            // Border
            ctx.strokeStyle = '#0f3460';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, width, height);
        }

        // Enhancement #10: Replay & Analysis System
        let replayMode = false;
        let replayData = [];
        let replayTime = 0;
        let replayPaused = false;
        let freeCamMode = false;
        let freeCamX = 0;
        let freeCamY = 0;

        function toggleReplayPause() {
            replayPaused = !replayPaused;
            document.getElementById('replayPauseBtn').textContent = replayPaused ? '‚ñ∂ Play' : '‚è∏ Pause';
        }

        function replaySeek(seconds) {
            replayTime = Math.max(0, Math.min(replayData.length - 1, replayTime + seconds * 10));
        }

        function toggleFreeCam() {
            freeCamMode = !freeCamMode;
            if (!freeCamMode) {
                panX = 0;
                panY = 0;
                zoomLevel = 1.0;
            }
        }

        function exitReplay() {
            replayMode = false;
            document.getElementById('replayControls').style.display = 'none';
            freeCamMode = false;
            panX = 0;
            panY = 0;
            zoomLevel = 1.0;
        }

        function startReplayMode() {
            replayMode = true;
            replayTime = 0;
            replayPaused = false;
            freeCamMode = false;
            document.getElementById('replayControls').style.display = 'block';

            // Capture current execution as replay data
            replayData = JSON.parse(JSON.stringify(executionRecording));
        }

        function updateReplay() {
            if (!replayMode || replayPaused) return;

            if (replayTime < replayData.length - 1) {
                replayTime++;
                const frame = replayData[Math.floor(replayTime)];

                // Apply frame data to aircraft
                if (frame) {
                    for (let i = 0; i < aircraft.length; i++) {
                        if (frame.aircraft && frame.aircraft[i]) {
                            Object.assign(aircraft[i], frame.aircraft[i]);
                        }
                    }
                }
            }
        }

        // Enhancement #3: Wingman/Squadron Formation System
        function setupSquadron(leaderAircraft, wingmenAircraft, formationType = 'finger_four') {
            squadron.leader = leaderAircraft;
            squadron.wingmen = wingmenAircraft;
            squadron.formation = formationType;
            squadron.inFormation = true;

            // Mark all as part of squadron
            leaderAircraft.isSquadronLeader = true;
            leaderAircraft.squadron = squadron;
            for (let wingman of wingmenAircraft) {
                wingman.isWingman = true;
                wingman.squadron = squadron;
                wingman.wingmanCommand = 'rejoin'; // Default: stay in formation
            }
        }

        function getFormationPosition(leaderAircraft, wingmanIndex, formationType) {
            const formation = formations[formationType] || formations['finger_four'];
            if (wingmanIndex >= formation.length) wingmanIndex = formation.length - 1;

            const offset = formation[wingmanIndex];

            // Convert leader's heading to radians
            const headingRad = (leaderAircraft.heading - 90) * Math.PI / 180;

            // Rotate offset by leader's heading
            const rotatedX = offset.x * Math.cos(headingRad) - offset.y * Math.sin(headingRad);
            const rotatedY = offset.x * Math.sin(headingRad) + offset.y * Math.cos(headingRad);

            return {
                x: leaderAircraft.x + rotatedX,
                y: leaderAircraft.y + rotatedY,
                altitude: leaderAircraft.altitude,
                heading: leaderAircraft.heading
            };
        }

        function issueWingmanCommand(command) {
            if (!squadron.leader || squadron.wingmen.length === 0) return;

            activeWingmanCommand = command;

            for (let wingman of squadron.wingmen) {
                wingman.wingmanCommand = command;
            }

            // Show command notification
            console.log(`Wingman Command: ${command.toUpperCase().replace('_', ' ')}`);
        }

        function applyWingmanAI(wingman) {
            if (!wingman.isWingman || !squadron.leader) return;

            const leader = squadron.leader;
            const command = wingman.wingmanCommand || 'rejoin';

            // Get wingman's formation position
            const wingmanIndex = squadron.wingmen.indexOf(wingman) + 1; // +1 because leader is position 0
            const formationPos = getFormationPosition(leader, wingmanIndex, squadron.formation);

            const dx = formationPos.x - wingman.x;
            const dy = formationPos.y - wingman.y;
            const distanceToFormation = Math.sqrt(dx * dx + dy * dy);

            switch (command) {
                case 'rejoin':
                case 'cover_me':
                    // Stay in formation
                    if (distanceToFormation > 30) {
                        // Move toward formation position
                        wingman.targetX = formationPos.x;
                        wingman.targetY = formationPos.y;
                        wingman.targetAltitude = formationPos.altitude;
                        wingman.targetHeading = formationPos.heading;
                    } else {
                        // In formation - match leader exactly
                        squadron.inFormation = true;
                        wingman.targetX = formationPos.x;
                        wingman.targetY = formationPos.y;
                        wingman.targetAltitude = leader.altitude;
                        wingman.targetHeading = leader.heading;
                        wingman.throttle = leader.throttle;
                    }
                    break;

                case 'attack_my_target':
                    // Find leader's target (closest enemy aircraft leader is attacking)
                    let leaderTarget = null;
                    let minDist = Infinity;
                    for (let plane of aircraft) {
                        if (plane.isPlayer === leader.isPlayer || plane.isDestroyed) continue;
                        const dx2 = plane.x - leader.x;
                        const dy2 = plane.y - leader.y;
                        const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                        if (dist < minDist) {
                            minDist = dist;
                            leaderTarget = plane;
                        }
                    }

                    if (leaderTarget) {
                        // Attack from different angle (coordinated attack)
                        const angleOffset = (wingmanIndex % 2 === 0) ? 45 : -45;
                        const targetAngle = (Math.atan2(leaderTarget.y - wingman.y, leaderTarget.x - wingman.x) * 180 / Math.PI + 90 + angleOffset + 360) % 360;

                        wingman.targetX = leaderTarget.x;
                        wingman.targetY = leaderTarget.y;
                        wingman.targetAltitude = leaderTarget.altitude;
                        wingman.targetHeading = targetAngle;
                        wingman.throttle = 1.0; // Full throttle for attack
                    }
                    break;

                case 'break_attack':
                    // Break formation and attack nearest enemy
                    squadron.inFormation = false;
                    generateAIOrders(wingman); // Use standard AI
                    break;

                case 'free_hunt':
                    // Independent hunting
                    squadron.inFormation = false;
                    generateAIOrders(wingman); // Use standard AI
                    break;
            }

            // Calculate formation bonus
            if (squadron.inFormation && distanceToFormation < 50) {
                squadron.formationBonus = 0.15; // 15% mutual defense bonus
            } else {
                squadron.formationBonus = 0;
            }
        }

        function changeFormation(newFormation) {
            if (formations[newFormation]) {
                squadron.formation = newFormation;
                console.log(`Formation changed to: ${newFormation}`);
            }
        }

        // Enhancement #14: Hot-seat Multiplayer Functions
        function enableHotSeatMode() {
            hotSeatMode = true;
            currentPlayer = 1;

            // Assign aircraft to players
            player1Aircraft = aircraft.filter(a => a.isPlayer);
            player2Aircraft = aircraft.filter(a => !a.isPlayer);

            // Mark all player2 aircraft as player-controlled for hot-seat
            for (let plane of player2Aircraft) {
                plane.isPlayer = true;
                plane.hotSeatPlayer = 2;
            }
            for (let plane of player1Aircraft) {
                plane.hotSeatPlayer = 1;
            }

            console.log('Hot-seat mode enabled!', {
                player1: player1Aircraft.map(a => a.name),
                player2: player2Aircraft.map(a => a.name)
            });

            updateUI();
        }

        function showPlayerSwitchScreen(playerNum) {
            awaitingPlayerSwitch = true;
            currentPlayer = playerNum;

            const screen = document.getElementById('playerSwitchScreen');
            const title = document.getElementById('playerSwitchTitle');

            title.textContent = `PASS DEVICE TO PLAYER ${playerNum}`;
            screen.style.display = 'flex';
        }

        function completePlayerSwitch() {
            const screen = document.getElementById('playerSwitchScreen');
            screen.style.display = 'none';
            awaitingPlayerSwitch = false;

            // Clear selection to prevent accidental viewing of opponent orders
            selectedAircraft = null;
            ghostAircraft = null;
            document.getElementById('ghostPanel').style.display = 'none';

            updateUI();
        }

        function canPlayerControlAircraft(aircraft) {
            if (!hotSeatMode) return aircraft.isPlayer;
            return aircraft.hotSeatPlayer === currentPlayer;
        }

        function getCurrentPlayerAircraft() {
            if (!hotSeatMode) return aircraft.filter(a => a.isPlayer);
            return currentPlayer === 1 ? player1Aircraft : player2Aircraft;
        }

        function getOpponentAircraft() {
            if (!hotSeatMode) return aircraft.filter(a => !a.isPlayer);
            return currentPlayer === 1 ? player2Aircraft : player1Aircraft;
        }

        function checkHotSeatOrdersComplete() {
            if (!hotSeatMode) return false;

            const currentPlayerPlanes = getCurrentPlayerAircraft();
            const allCurrentPlayerHaveOrders = currentPlayerPlanes.every(a => a.hasOrders || a.isDestroyed);

            if (allCurrentPlayerHaveOrders) {
                // Switch to other player
                if (currentPlayer === 1) {
                    // Player 1 done, switch to player 2
                    showPlayerSwitchScreen(2);
                    return false; // Not ready to execute yet
                } else {
                    // Player 2 done, ready to execute
                    return true;
                }
            }

            return false;
        }

        // Enhancement #1: Campaign/Mission System
        function loadMission(missionId) {
            currentMission = missions.find(m => m.id === missionId) || missions[0];
            campaignState.currentMission = missionId;

            // Show mission briefing
            showMissionBriefing();
        }

        function showMissionBriefing() {
            const briefing = document.getElementById('briefingContent');
            briefing.innerHTML = `
                <h3 style="color: #e94560;">Mission ${currentMission.id}: ${currentMission.name}</h3>
                <p style="margin: 10px 0; color: #ccc;">${currentMission.description}</p>
                <h4 style="color: #0f9d58; margin-top: 15px;">Objectives:</h4>
                <ul style="margin: 10px 0; padding-left: 20px;">
                    ${currentMission.objectives.map(obj => `<li>${obj}</li>`).join('')}
                </ul>
                <div style="margin-top: 15px; color: #aaa;">
                    <div>Aircraft: ${currentMission.playerAircraft}</div>
                    <div>Weather: ${currentMission.weather}</div>
                    <div>Time of Day: ${currentMission.timeOfDay}</div>
                </div>
            `;
            document.getElementById('missionBriefing').style.display = 'block';
        }

        function startMission() {
            document.getElementById('missionBriefing').style.display = 'none';

            // Initialize mission
            gameState = 'ORDER';
            currentTurn = 1;
            groundTargets = [];

            // Set weather
            applyWeather(currentMission.weather);

            // Create player aircraft
            spitfire = new Aircraft('Player', currentMission.playerAircraft, 400, 500, 500, 90, true);
            aircraft = [spitfire];

            // Create enemy aircraft
            for (let i = 0; i < currentMission.enemyAircraft.length; i++) {
                const enemyType = currentMission.enemyAircraft[i];
                const enemy = new Aircraft(`Enemy ${i+1}`, enemyType, 1400 + i * 100, 500 + i * 50, 500, 270, false);
                aircraft.push(enemy);
            }

            // Create ground targets if needed
            if (currentMission.groundTargets) {
                for (let i = 0; i < currentMission.groundTargets; i++) {
                    const types = ['truck', 'aa_gun', 'fuel_depot'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    const x = 600 + Math.random() * 600;
                    const y = 300 + Math.random() * 400;
                    groundTargets.push(new GroundTarget(x, y, type));
                }
            }

            // Re-assign references (for backward compatibility)
            if (aircraft[1]) {
                me109 = aircraft[1];
            }

            // Start game loop if not already running
            if (gameState === 'ORDER') {
                gameLoop();
            }
        }

        function checkMissionObjectives() {
            if (!currentMission) return;

            let objectivesComplete = 0;
            const totalObjectives = currentMission.objectives.length;

            // Check objectives based on mission type
            if (currentMission.type === 'dogfight') {
                // Destroy all enemies
                const enemiesDestroyed = aircraft.filter(a => !a.isPlayer && a.isDestroyed).length;
                if (enemiesDestroyed === currentMission.enemyAircraft.length) {
                    objectivesComplete++;
                }
            } else if (currentMission.type === 'ground_attack') {
                // Destroy ground targets
                const targetsDestroyed = groundTargets.filter(t => t.isDestroyed).length;
                if (targetsDestroyed >= currentMission.groundTargets) {
                    objectivesComplete++;
                }
                // Survive
                if (!spitfire.isDestroyed) {
                    objectivesComplete++;
                }
            }

            // Mission complete?
            if (objectivesComplete === totalObjectives) {
                completeMission();
            }
        }

        function completeMission() {
            campaignState.missionsCompleted++;
            campaignState.pilotExperience += 100;
            campaignState.score += 1000;

            setTimeout(() => {
                alert(`Mission Complete!\n\nScore: +1000\nExperience: +100\n\nTotal Score: ${campaignState.score}`);

                // Load next mission or show campaign complete
                if (currentMission.id < missions.length) {
                    loadMission(currentMission.id + 1);
                } else {
                    alert('Campaign Complete! You are victorious!');
                }
            }, 1000);
        }

        // Splash Screen Functions
        function hideSplashScreen() {
            document.getElementById('splashScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
        }

        function startQuickBattle() {
            hideSplashScreen();

            // Reset game state
            gameState = 'ORDER';
            currentTurn = 1;
            groundTargets = [];
            executionRecording = [];

            // Create default aircraft
            spitfire = new Aircraft('Spitfire', 'Spitfire', 400, 500, 500, 90, true);
            me109 = new Aircraft('Me-109', 'Me-109', 1400, 500, 500, 270, false);
            aircraft = [spitfire, me109];

            // Start game loop
            gameLoop();
        }

        function startCampaign() {
            hideSplashScreen();

            // Load first mission
            loadMission(1);
        }

        function showAircraftSelector() {
            document.getElementById('splashScreen').style.display = 'none';
            document.getElementById('aircraftSelector').style.display = 'block';
        }

        function startCustomBattle() {
            document.getElementById('aircraftSelector').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';

            // Get selected aircraft
            const playerType = document.getElementById('playerAircraftSelect').value;
            const enemyType = document.getElementById('enemyAircraftSelect').value;

            // Reset game state
            gameState = 'ORDER';
            currentTurn = 1;
            groundTargets = [];
            executionRecording = [];

            // Create selected aircraft
            spitfire = new Aircraft('Player', playerType, 400, 500, 500, 90, true);
            me109 = new Aircraft('Enemy', enemyType, 1400, 500, 500, 270, false);
            aircraft = [spitfire, me109];

            // Start game loop
            gameLoop();
        }

        // Event listeners
        document.getElementById('restartButton').addEventListener('click', restartGame);
        document.getElementById('pauseButton').addEventListener('click', togglePause);
        document.getElementById('settingsButton').addEventListener('click', openSettings);

        // Game will start when user selects mode from splash screen
        // gameLoop() called from startQuickBattle() or startCustomBattle()
    </script>
</body>
</html>
