<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dogfight 2 - Aerial Combat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #0f3460;
            background: #16213e;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            min-width: 250px;
        }

        #executeButton {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
            font-family: 'Courier New', monospace;
        }

        #executeButton:hover {
            background: #c23555;
        }

        #executeButton:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #replayButton, #nextPhaseButton {
            position: absolute;
            bottom: 30px;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
            font-family: 'Courier New', monospace;
        }

        #replayButton {
            left: 50%;
            transform: translateX(-120%);
        }

        #nextPhaseButton {
            left: 50%;
            transform: translateX(20%);
        }

        #replayButton:hover, #nextPhaseButton:hover {
            background: #1a4d7a;
        }

        .warning {
            color: #e94560;
            font-weight: bold;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            50% { opacity: 0.3; }
        }

        .stat-line {
            margin: 5px 0;
            font-size: 14px;
        }

        .ghost-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border: 2px solid #0f3460;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            display: none;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 20px;
            color: #e94560;
        }

        h2 {
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 16px;
            color: #0f9d58;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>

        <div id="ui">
            <h1>DOGFIGHT 2</h1>
            <div id="phaseDisplay" class="stat-line">Phase: <span id="currentPhase">ORDER</span></div>
            <div id="turnDisplay" class="stat-line">Turn: <span id="currentTurn">1</span></div>

            <h2>Spitfire (You)</h2>
            <div id="spitfireStats"></div>

            <h2>Me-109 (Enemy)</h2>
            <div id="me109Stats"></div>

            <div style="margin-top: 15px; font-size: 11px; color: #888;">
                <div>Controls:</div>
                <div>• Click aircraft to order</div>
                <div>• Move mouse to position</div>
                <div>• Mouse wheel: rotate (in maneuver) / zoom (otherwise)</div>
                <div>• W/S: altitude up/down</div>
                <div>• A/D: fire threshold</div>
                <div>• Click again to lock</div>
            </div>
        </div>

        <div id="ghostPanel" class="ghost-panel"></div>

        <button id="executeButton">EXECUTE ORDERS</button>
        <button id="replayButton">REPLAY</button>
        <button id="nextPhaseButton">NEXT PHASE</button>
    </div>

    <script>
        // Game constants
        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;
        const EXECUTION_TIME = 4000; // 4 seconds
        const TURN_TIME = 4; // execution time in seconds (matches EXECUTION_TIME)
        const ALTITUDE_MIN = 0;
        const ALTITUDE_MAX = 3000; // meters
        const MOUNTAIN_HEIGHT = 1000; // meters

        // Game state
        let gameState = 'ORDER'; // ORDER, EXECUTION, REVIEW
        let currentTurn = 1;
        let selectedAircraft = null;
        let ghostAircraft = null;
        let executionStartTime = 0;
        let executionRecording = [];

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Terrain generation
        class Terrain {
            constructor() {
                this.mountains = [];
                this.generateMountains();
            }

            generateMountains() {
                // Generate random mountains
                for (let i = 0; i < 15; i++) {
                    this.mountains.push({
                        x: Math.random() * CANVAS_WIDTH,
                        y: Math.random() * CANVAS_HEIGHT,
                        radius: 30 + Math.random() * 80,
                        height: 200 + Math.random() * 800
                    });
                }
            }

            getHeightAt(x, y) {
                let maxHeight = 0;
                for (let mountain of this.mountains) {
                    const dx = x - mountain.x;
                    const dy = y - mountain.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < mountain.radius) {
                        const heightAtPoint = mountain.height * (1 - dist / mountain.radius);
                        maxHeight = Math.max(maxHeight, heightAtPoint);
                    }
                }
                return maxHeight;
            }

            render() {
                for (let mountain of this.mountains) {
                    const gradient = ctx.createRadialGradient(
                        mountain.x, mountain.y, 0,
                        mountain.x, mountain.y, mountain.radius
                    );
                    const intensity = mountain.height / MOUNTAIN_HEIGHT;
                    gradient.addColorStop(0, `rgba(80, 80, 60, ${intensity * 0.6})`);
                    gradient.addColorStop(1, 'rgba(40, 40, 30, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(mountain.x, mountain.y, mountain.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Aircraft class
        class Aircraft {
            constructor(name, type, x, y, altitude, heading, isPlayer = false) {
                this.name = name;
                this.type = type;
                this.x = x;
                this.y = y;
                this.altitude = altitude;
                this.heading = heading; // degrees
                this.speed = 200; // m/s
                this.isPlayer = isPlayer;
                this.hasOrders = false;
                this.targetX = x;
                this.targetY = y;
                this.targetAltitude = altitude;
                this.targetHeading = heading;
                this.targetSpeed = 200;

                // Starting positions for interpolation
                this.startX = x;
                this.startY = y;
                this.startAltitude = altitude;
                this.startHeading = heading;
                this.startSpeed = 140; // Start at cruise speed

                // Performance characteristics (historically accurate)
                if (type === 'Spitfire') {
                    this.maxSpeed = 170; // m/s (~600 km/h at altitude)
                    this.minSpeed = 30; // m/s (~108 km/h stall speed)
                    this.maxTurnRate = 72; // degrees per turn (18°/sec × 4 sec)
                    this.maxClimbRate = 15; // m/s
                    this.maxDiveRate = 30; // m/s
                    this.maxGForce = 7;
                    this.maxAcceleration = 15; // m/s²
                    this.maxBraking = 20; // m/s²
                } else { // Me-109
                    this.maxSpeed = 175; // m/s (~630 km/h, slightly faster than Spitfire)
                    this.minSpeed = 30; // m/s (~108 km/h stall speed)
                    this.maxTurnRate = 64; // degrees per turn (16°/sec × 4 sec, slightly worse than Spitfire)
                    this.maxClimbRate = 17; // m/s (slightly better climb)
                    this.maxDiveRate = 35; // m/s
                    this.maxGForce = 6.5;
                    this.maxAcceleration = 17; // m/s²
                    this.maxBraking = 18; // m/s²
                }

                // Combat stats
                this.ammunition = 500;
                this.damage = 0;
                this.fireThreshold = 0.3; // 30% hit chance to fire
                this.timeOnTarget = 0;
                this.pilotSkill = 0.5 + Math.random() * 0.3; // 50-80%
                this.gunnerySkill = 0.5 + Math.random() * 0.3;

                // Flight path calculation
                this.flightPath = null; // Will store calculated realistic path
                this.inStall = false; // Track if aircraft is stalled
            }

            getScaleForAltitude() {
                // Higher altitude = larger visual size
                const baseScale = 0.5;
                const altitudeFactor = this.altitude / 1000;
                return baseScale + altitudeFactor * 0.5;
            }

            renderSVG(isGhost = false, ghostState = 'valid') {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate((this.heading * Math.PI) / 180);

                const scale = this.getScaleForAltitude();
                ctx.scale(scale, scale);

                // Set color based on state
                if (isGhost) {
                    if (ghostState === 'illegal') {
                        ctx.globalAlpha = 0.7;
                        ctx.fillStyle = '#ff0000';
                        ctx.strokeStyle = '#ff0000';
                    } else if (ghostState === 'stressful') {
                        ctx.globalAlpha = 0.7;
                        ctx.fillStyle = '#ffff00';
                        ctx.strokeStyle = '#ffff00';
                    } else {
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = '#00ff00';
                        ctx.strokeStyle = '#00ff00';
                    }
                } else {
                    if (this.isPlayer) {
                        ctx.fillStyle = '#0099ff';
                        ctx.strokeStyle = '#0099ff';
                    } else {
                        ctx.fillStyle = '#ff4444';
                        ctx.strokeStyle = '#ff4444';
                    }
                }

                ctx.lineWidth = 2;

                // Draw aircraft shape (simplified top-down view)
                ctx.beginPath();
                // Fuselage
                ctx.moveTo(0, -30);
                ctx.lineTo(-5, 10);
                ctx.lineTo(5, 10);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Wings
                ctx.beginPath();
                ctx.moveTo(-25, 0);
                ctx.lineTo(-5, 0);
                ctx.moveTo(5, 0);
                ctx.lineTo(25, 0);
                ctx.stroke();

                // Tail
                ctx.beginPath();
                ctx.moveTo(-8, 10);
                ctx.lineTo(-8, 15);
                ctx.moveTo(8, 10);
                ctx.lineTo(8, 15);
                ctx.stroke();

                // Draw orders indicator
                if (!isGhost && this.hasOrders) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 35, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                // Draw altitude indicator
                if (!isGhost) {
                    ctx.fillStyle = this.isPlayer ? '#0099ff' : '#ff4444';
                    ctx.font = '12px Courier New';
                    ctx.fillText(`${Math.round(this.altitude)}m`, this.x + 20, this.y - 20);
                }
            }

            isClicked(mouseX, mouseY) {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < 40 * this.getScaleForAltitude();
            }

            // Calculate realistic flight path using physics simulation
            calculateRealisticPath(targetX, targetY, targetAltitude, targetHeading) {
                const TIME_STEP = 0.1; // 0.1 second time steps
                const NUM_STEPS = Math.floor(TURN_TIME / TIME_STEP); // 40 steps
                const g = 9.81;

                // Path array storing state at each time step
                let path = [];

                // Current state (will be updated each step)
                let state = {
                    x: this.x,
                    y: this.y,
                    altitude: this.altitude,
                    heading: this.heading,
                    speed: this.speed,
                    time: 0
                };

                // Validation tracking
                let overallState = 'valid'; // 'valid', 'stressful', or 'illegal'
                let warnings = [];
                let maxGForce = 0;

                // Add starting point
                path.push({...state});

                for (let step = 0; step < NUM_STEPS; step++) {
                    const stepTime = (step + 1) * TIME_STEP;

                    // Calculate desired heading towards target
                    const dx = targetX - state.x;
                    const dy = targetY - state.y;
                    const distanceRemaining = Math.sqrt(dx * dx + dy * dy);
                    const desiredHeading = (Math.atan2(dy, dx) * 180 / Math.PI + 90 + 360) % 360;

                    // Calculate heading difference (shortest angle)
                    let headingDiff = desiredHeading - state.heading;
                    if (headingDiff > 180) headingDiff -= 360;
                    if (headingDiff < -180) headingDiff += 360;

                    // Calculate maximum turn rate based on current speed and G-limits
                    // Turn radius: r = v² / (g × √(n² - 1)) where n is load factor (G-force)
                    // For now, use max sustainable G for turn rate calculation
                    const maxSustainableG = this.maxGForce * 0.8; // Use 80% of max for sustained
                    const turnRadius = (state.speed * state.speed) / (g * Math.sqrt(maxSustainableG * maxSustainableG - 1));
                    const maxTurnRatePerSec = (state.speed / turnRadius) * (180 / Math.PI); // Convert to degrees/sec
                    const maxTurnThisStep = maxTurnRatePerSec * TIME_STEP;

                    // Apply turn rate limit
                    const actualTurn = Math.max(-maxTurnThisStep, Math.min(maxTurnThisStep, headingDiff));
                    const newHeading = (state.heading + actualTurn + 360) % 360;

                    // Calculate actual G-force from this turn
                    const turnRateRadPerSec = (Math.abs(actualTurn) / TIME_STEP) * (Math.PI / 180);
                    const actualTurnRadius = turnRateRadPerSec > 0 ? state.speed / turnRateRadPerSec : Infinity;
                    const turnGForce = actualTurnRadius !== Infinity ? (state.speed * state.speed) / (actualTurnRadius * g) : 0;

                    // Calculate desired altitude change
                    const altitudeRemaining = targetAltitude - state.altitude;
                    const timeRemaining = TURN_TIME - stepTime;
                    const desiredClimbRate = timeRemaining > 0 ? altitudeRemaining / timeRemaining : 0;

                    // Limit climb/dive rate
                    let actualClimbRate = desiredClimbRate;
                    if (actualClimbRate > this.maxClimbRate) {
                        actualClimbRate = this.maxClimbRate;
                    } else if (actualClimbRate < -this.maxDiveRate) {
                        actualClimbRate = -this.maxDiveRate;
                    }

                    // Calculate altitude change this step
                    const altitudeChange = actualClimbRate * TIME_STEP;
                    const newAltitude = state.altitude + altitudeChange;

                    // Energy management: altitude affects speed
                    // Base energy equation: v² = v₀² - 2g·Δh
                    let energySpeed = state.speed;
                    const energySpeedSquared = state.speed * state.speed - 2 * g * altitudeChange;
                    if (energySpeedSquared > 0) {
                        energySpeed = Math.sqrt(energySpeedSquared);
                    } else {
                        energySpeed = this.minSpeed;
                    }

                    // Pilot throttle compensation
                    // When climbing: pilot applies full throttle to maintain speed
                    // When diving: pilot reduces throttle to avoid overspeed
                    let throttleAdjustment = 0;
                    if (altitudeChange > 0) {
                        // Climbing: add throttle (can add ~5-10 m/s per second at full throttle)
                        throttleAdjustment = this.maxAcceleration * TIME_STEP * 0.6; // 60% effective
                    } else if (altitudeChange < 0) {
                        // Diving: reduce throttle
                        throttleAdjustment = -this.maxBraking * TIME_STEP * 0.4; // 40% braking effectiveness
                    }

                    let newSpeed = energySpeed + throttleAdjustment;

                    // Combined maneuver energy sharing
                    // Turning while climbing/diving reduces efficiency
                    if (Math.abs(altitudeChange) > 0 && Math.abs(actualTurn) > 0) {
                        const maneuverIntensity = (Math.abs(actualTurn) / maxTurnThisStep) * (Math.abs(actualClimbRate) / this.maxClimbRate);
                        newSpeed *= (1 - maneuverIntensity * 0.1); // Up to 10% speed loss for combined maneuvers
                    }

                    // Clamp speed
                    newSpeed = Math.max(this.minSpeed, Math.min(this.maxSpeed * 1.2, newSpeed));

                    // Move aircraft forward
                    const avgSpeed = (state.speed + newSpeed) / 2;
                    const distance = avgSpeed * TIME_STEP;
                    const headingRad = (newHeading - 90) * Math.PI / 180;
                    const newX = state.x + Math.cos(headingRad) * distance;
                    const newY = state.y + Math.sin(headingRad) * distance;

                    // Check for slip/skid (lateral forces during turn)
                    let slipWarning = null;
                    if (turnGForce > 0) {
                        const bankAngle = Math.atan(turnGForce) * 180 / Math.PI;
                        // Ideally, bank angle should match turn rate
                        // If turning too fast for bank angle, you're skidding
                        // If bank too steep for turn rate, you're slipping
                        // Simplified: warn if turning hard (>50% of max G)
                        if (turnGForce > this.maxGForce * 0.5) {
                            slipWarning = `Skid/Slip at ${stepTime.toFixed(1)}s`;
                        }
                    }

                    // Update state
                    state = {
                        x: newX,
                        y: newY,
                        altitude: newAltitude,
                        heading: newHeading,
                        speed: newSpeed,
                        time: stepTime,
                        gForce: turnGForce,
                        climbRate: actualClimbRate
                    };

                    path.push({...state});

                    // Track max G-force
                    if (turnGForce > maxGForce) maxGForce = turnGForce;

                    // Validation checks
                    // Speed checks
                    if (newSpeed > this.maxSpeed * 1.2) {
                        overallState = 'illegal';
                        warnings.push(`Speed too high at ${stepTime.toFixed(1)}s (${Math.round(newSpeed)} m/s)`);
                    } else if (newSpeed > this.maxSpeed) {
                        if (overallState !== 'illegal') overallState = 'stressful';
                        if (!warnings.some(w => w.includes('Overspeed'))) {
                            warnings.push(`Overspeed at ${stepTime.toFixed(1)}s - Damage`);
                        }
                    } else if (newSpeed < this.minSpeed) {
                        if (overallState !== 'illegal') overallState = 'stressful';
                        if (!warnings.some(w => w.includes('STALL'))) {
                            warnings.push(`STALL WARNING at ${stepTime.toFixed(1)}s`);
                        }
                    }

                    // G-force check
                    if (turnGForce > this.maxGForce) {
                        overallState = 'illegal';
                        warnings.push(`G-force exceeded at ${stepTime.toFixed(1)}s (${turnGForce.toFixed(1)}G)`);
                    } else if (turnGForce > this.maxGForce * 0.85) {
                        if (overallState !== 'illegal') overallState = 'stressful';
                        if (!warnings.some(w => w.includes('High G'))) {
                            warnings.push(`High G-force (${turnGForce.toFixed(1)}G)`);
                        }
                    }

                    // Slip/skid warning
                    if (slipWarning && overallState !== 'illegal') {
                        overallState = 'stressful';
                        if (!warnings.some(w => w.includes('Skid'))) {
                            warnings.push(slipWarning);
                        }
                    }

                    // Terrain check
                    const terrainHeight = terrain.getHeightAt(newX, newY);
                    if (newAltitude < terrainHeight + 50) {
                        overallState = 'illegal';
                        warnings.push(`⚠ TERRAIN at ${stepTime.toFixed(1)}s ⚠`);
                    }
                }

                // Final position check - how close did we get?
                const finalState = path[path.length - 1];
                const finalDist = Math.sqrt((finalState.x - targetX)**2 + (finalState.y - targetY)**2);
                const finalAltDiff = Math.abs(finalState.altitude - targetAltitude);
                const finalHeadingDiff = Math.abs(finalState.heading - targetHeading);

                if (finalDist > 100) {
                    if (overallState !== 'illegal') overallState = 'stressful';
                    warnings.push(`Won't reach target (${Math.round(finalDist)}m short)`);
                }

                return {
                    path: path,
                    state: overallState,
                    warnings: warnings,
                    targetSpeed: Math.round(finalState.speed),
                    gForce: maxGForce.toFixed(1),
                    climbRate: Math.round(Math.abs(finalState.climbRate)),
                    targetAltitude: Math.round(targetAltitude),
                    targetHeading: Math.round(targetHeading)
                };
            }

            calculateManeuverValidation(targetX, targetY, targetAltitude, targetHeading) {
                // Use the new realistic path calculation
                const result = this.calculateRealisticPath(targetX, targetY, targetAltitude, targetHeading);

                // Store the path for rendering and execution
                this.flightPath = result.path;

                return result;
            }

            lockOrders(targetX, targetY, targetAltitude, targetHeading) {
                // Save starting position for interpolation
                this.startX = this.x;
                this.startY = this.y;
                this.startAltitude = this.altitude;
                this.startHeading = this.heading;
                this.startSpeed = this.speed;

                this.targetX = targetX;
                this.targetY = targetY;
                this.targetAltitude = targetAltitude;
                this.targetHeading = targetHeading;
                this.hasOrders = true;

                // Calculate target speed: distance / time
                const dx = targetX - this.startX;
                const dy = targetY - this.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.targetSpeed = distance / TURN_TIME;
            }

            unlockOrders() {
                this.hasOrders = false;
                this.targetX = this.x;
                this.targetY = this.y;
                this.targetAltitude = this.altitude;
                this.targetHeading = this.heading;
            }

            executeOrders(progress) {
                // progress goes from 0 to 1
                // Follow the precalculated realistic flight path
                if (this.flightPath && this.flightPath.length > 1) {
                    // Find the point in the path corresponding to current progress
                    const pathIndex = Math.floor(progress * (this.flightPath.length - 1));
                    const nextIndex = Math.min(pathIndex + 1, this.flightPath.length - 1);

                    // Interpolate between path points for smooth animation
                    const localProgress = (progress * (this.flightPath.length - 1)) - pathIndex;

                    const current = this.flightPath[pathIndex];
                    const next = this.flightPath[nextIndex];

                    this.x = current.x + (next.x - current.x) * localProgress;
                    this.y = current.y + (next.y - current.y) * localProgress;
                    this.altitude = current.altitude + (next.altitude - current.altitude) * localProgress;
                    this.heading = current.heading + (next.heading - current.heading) * localProgress;
                    this.speed = current.speed + (next.speed - current.speed) * localProgress;

                    // Handle heading wraparound
                    if (this.heading < 0) this.heading += 360;
                    if (this.heading >= 360) this.heading -= 360;

                    // Check for stall condition
                    if (this.speed < this.minSpeed) {
                        this.inStall = true;
                    }

                    // Apply damage for stressful maneuvers
                    if (current.gForce && current.gForce > this.maxGForce * 0.85) {
                        this.damage += 0.1; // Gradual damage from high G
                    }
                } else {
                    // Fallback to old linear interpolation if no path (shouldn't happen)
                    this.x = this.startX + (this.targetX - this.startX) * progress;
                    this.y = this.startY + (this.targetY - this.startY) * progress;
                    this.altitude = this.startAltitude + (this.targetAltitude - this.startAltitude) * progress;

                    let headingDiff = this.targetHeading - this.startHeading;
                    if (headingDiff > 180) headingDiff -= 360;
                    if (headingDiff < -180) headingDiff += 360;
                    this.heading = this.startHeading + headingDiff * progress;

                    if (this.heading < 0) this.heading += 360;
                    if (this.heading >= 360) this.heading -= 360;

                    this.speed = this.startSpeed + (this.targetSpeed - this.startSpeed) * progress;
                }
            }

            finalizeExecution() {
                this.x = this.targetX;
                this.y = this.targetY;
                this.altitude = this.targetAltitude;
                this.heading = this.targetHeading;
                this.speed = this.targetSpeed;
                this.hasOrders = false;
            }

            getStatsHTML() {
                return `
                    <div class="stat-line">Alt: ${Math.round(this.altitude)}m</div>
                    <div class="stat-line">Speed: ${Math.round(this.speed)} m/s</div>
                    <div class="stat-line">Hdg: ${Math.round(this.heading)}°</div>
                    <div class="stat-line">Ammo: ${this.ammunition}</div>
                    <div class="stat-line">Damage: ${Math.round(this.damage)}%</div>
                    <div class="stat-line">Fire Threshold: ${Math.round(this.fireThreshold * 100)}%</div>
                `;
            }
        }

        // Initialize game
        const terrain = new Terrain();
        const spitfire = new Aircraft('Spitfire', 'Spitfire', 300, 400, 500, 90, true);
        const me109 = new Aircraft('Me-109', 'Me-109', 800, 400, 500, 270, false);
        const aircraft = [spitfire, me109];

        // AI for Me-109
        function generateAIOrders() {
            if (me109.hasOrders) return;

            // Simple AI: try to get behind the Spitfire
            const dx = spitfire.x - me109.x;
            const dy = spitfire.y - me109.y;
            const angleToTarget = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;

            // Move towards a position behind the Spitfire
            const behindX = spitfire.x - Math.cos(spitfire.heading * Math.PI / 180) * 150;
            const behindY = spitfire.y - Math.sin(spitfire.heading * Math.PI / 180) * 150;

            // Constrain to canvas
            const targetX = Math.max(50, Math.min(CANVAS_WIDTH - 50, behindX));
            const targetY = Math.max(50, Math.min(CANVAS_HEIGHT - 50, behindY));

            // Adjust altitude based on terrain and tactical position
            const terrainHeight = terrain.getHeightAt(targetX, targetY);
            let targetAltitude = Math.max(terrainHeight + 100, spitfire.altitude - 100);
            targetAltitude = Math.max(ALTITUDE_MIN, Math.min(ALTITUDE_MAX, targetAltitude));

            // Face towards Spitfire
            const targetHeading = angleToTarget;

            // Validate and lock if valid
            const validation = me109.calculateManeuverValidation(targetX, targetY, targetAltitude, targetHeading);
            if (validation.state !== 'illegal') {
                me109.lockOrders(targetX, targetY, targetAltitude, targetHeading);
            } else {
                // Fallback: simple forward movement
                const fallbackX = me109.x + Math.cos(me109.heading * Math.PI / 180) * 80;
                const fallbackY = me109.y + Math.sin(me109.heading * Math.PI / 180) * 80;
                me109.lockOrders(
                    Math.max(50, Math.min(CANVAS_WIDTH - 50, fallbackX)),
                    Math.max(50, Math.min(CANVAS_HEIGHT - 50, fallbackY)),
                    me109.altitude,
                    me109.heading
                );
            }
        }

        // Combat system
        function processCombat() {
            // Check if aircraft can fire at each other
            for (let shooter of aircraft) {
                if (shooter.ammunition <= 0) continue;

                for (let target of aircraft) {
                    if (shooter === target) continue;

                    // Calculate if target is in firing arc (roughly 30 degrees in front)
                    const dx = target.x - shooter.x;
                    const dy = target.y - shooter.y;
                    const angleToTarget = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
                    let angleDiff = Math.abs(angleToTarget - shooter.heading);
                    if (angleDiff > 180) angleDiff = 360 - angleDiff;

                    if (angleDiff < 30) {
                        // Target is in arc
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const altitudeDiff = Math.abs(target.altitude - shooter.altitude);

                        // Calculate hit chance
                        let hitChance = shooter.gunnerySkill * 0.5;
                        hitChance *= Math.max(0.1, 1 - distance / 500); // Distance factor
                        hitChance *= Math.max(0.5, 1 - altitudeDiff / 1000); // Altitude factor
                        hitChance *= Math.min(1, 0.3 + shooter.timeOnTarget / 10); // Time on target bonus

                        shooter.timeOnTarget += 0.1;

                        // Fire if chance exceeds threshold
                        if (hitChance >= shooter.fireThreshold) {
                            shooter.ammunition -= 5;

                            // Check if hit
                            if (Math.random() < hitChance) {
                                target.damage += 2 + Math.random() * 3;
                            }
                        }
                    } else {
                        shooter.timeOnTarget = 0;
                    }
                }
            }
        }

        // Rendering
        function render() {
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Apply zoom transform
            ctx.save();
            ctx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-CANVAS_WIDTH / 2, -CANVAS_HEIGHT / 2);

            // Render terrain
            terrain.render();

            // Render flight paths (dotted lines)
            for (let plane of aircraft) {
                if (plane.flightPath && plane.flightPath.length > 1) {
                    ctx.strokeStyle = plane.isPlayer ? '#00aaff' : '#ff6666';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]); // Dotted line

                    ctx.beginPath();
                    ctx.moveTo(plane.flightPath[0].x, plane.flightPath[0].y);
                    for (let i = 1; i < plane.flightPath.length; i++) {
                        ctx.lineTo(plane.flightPath[i].x, plane.flightPath[i].y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset to solid line
                }
            }

            // Render ghost aircraft flight path
            if (ghostAircraft && ghostAircraft.aircraft.flightPath && ghostAircraft.aircraft.flightPath.length > 1) {
                // Color based on validation state
                let pathColor = '#00ff00'; // valid = green
                if (ghostAircraft.state === 'stressful') pathColor = '#ffaa00'; // yellow
                if (ghostAircraft.state === 'illegal') pathColor = '#ff0000'; // red

                ctx.strokeStyle = pathColor;
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 4]); // Dotted line

                ctx.beginPath();
                ctx.moveTo(ghostAircraft.aircraft.flightPath[0].x, ghostAircraft.aircraft.flightPath[0].y);
                for (let i = 1; i < ghostAircraft.aircraft.flightPath.length; i++) {
                    ctx.lineTo(ghostAircraft.aircraft.flightPath[i].x, ghostAircraft.aircraft.flightPath[i].y);
                }
                ctx.stroke();
                ctx.setLineDash([]); // Reset to solid line
            }

            // Render aircraft
            for (let plane of aircraft) {
                plane.renderSVG();
            }

            // Render ghost if in order mode
            if (ghostAircraft) {
                ghostAircraft.aircraft.renderSVG(true, ghostAircraft.state);
            }

            ctx.restore();
        }

        function updateUI() {
            document.getElementById('currentPhase').textContent = gameState;
            document.getElementById('currentTurn').textContent = currentTurn;
            document.getElementById('spitfireStats').innerHTML = spitfire.getStatsHTML();
            document.getElementById('me109Stats').innerHTML = me109.getStatsHTML();

            // Show execute button if all aircraft have orders
            const allHaveOrders = aircraft.every(a => a.hasOrders);
            document.getElementById('executeButton').style.display =
                (gameState === 'ORDER' && allHaveOrders) ? 'block' : 'none';
        }

        // Mouse handling
        let mouseX = 0;
        let mouseY = 0;
        let ghostRotation = 0;
        let ghostAltitudeOffset = 0;
        let zoomLevel = 1.0; // Zoom level for canvas (1.0 = no zoom)

        // Helper function to transform screen coordinates to canvas coordinates (accounting for zoom)
        function screenToCanvas(screenX, screenY) {
            // Screen coords relative to canvas element
            // Need to reverse the zoom transformation:
            // 1. Translate to origin (center of canvas)
            // 2. Divide by zoom (inverse of scale)
            // 3. Translate back
            const centerX = CANVAS_WIDTH / 2;
            const centerY = CANVAS_HEIGHT / 2;

            const canvasX = centerX + (screenX - centerX) / zoomLevel;
            const canvasY = centerY + (screenY - centerY) / zoomLevel;

            return { x: canvasX, y: canvasY };
        }

        // Helper function to update ghost aircraft position and validation
        function updateGhost() {
            if (!selectedAircraft || !ghostAircraft) return;

            // Target position (where mouse is pointing)
            const targetX = mouseX;
            const targetY = mouseY;
            const targetHeading = (selectedAircraft.heading + ghostRotation + 360) % 360;
            const targetAltitude = Math.max(ALTITUDE_MIN,
                Math.min(ALTITUDE_MAX, selectedAircraft.altitude + ghostAltitudeOffset));

            // Calculate realistic path from current position to target
            const validation = selectedAircraft.calculateManeuverValidation(
                targetX,
                targetY,
                targetAltitude,
                targetHeading
            );

            ghostAircraft.state = validation.state;
            ghostAircraft.validation = validation;

            // Copy the calculated flight path to the ghost aircraft for rendering
            ghostAircraft.aircraft.flightPath = selectedAircraft.flightPath;

            // Position ghost at the END of the calculated path (where aircraft will actually end up)
            if (selectedAircraft.flightPath && selectedAircraft.flightPath.length > 0) {
                const finalState = selectedAircraft.flightPath[selectedAircraft.flightPath.length - 1];
                ghostAircraft.aircraft.x = finalState.x;
                ghostAircraft.aircraft.y = finalState.y;
                ghostAircraft.aircraft.altitude = finalState.altitude;
                ghostAircraft.aircraft.heading = finalState.heading;
            } else {
                // Fallback if no path calculated
                ghostAircraft.aircraft.x = targetX;
                ghostAircraft.aircraft.y = targetY;
                ghostAircraft.aircraft.altitude = targetAltitude;
                ghostAircraft.aircraft.heading = targetHeading;
            }
        }

        // Helper function to update ghost panel
        function updateGhostPanel() {
            if (!ghostAircraft || !ghostAircraft.validation) return;

            const panel = document.getElementById('ghostPanel');
            panel.style.display = 'block';
            panel.style.left = (lastScreenX + 50) + 'px';
            panel.style.top = (lastScreenY - 50) + 'px';

            const validation = ghostAircraft.validation;
            let panelHTML = `
                <div>Heading: ${validation.targetHeading}°</div>
                <div>Altitude: ${validation.targetAltitude}m</div>
                <div>Speed: ${validation.targetSpeed} m/s</div>
                <div>G-Force: ${validation.gForce}G</div>
            `;

            if (validation.warnings.length > 0) {
                panelHTML += '<div style="color: #ff4444; margin-top: 5px;">';
                for (let warning of validation.warnings) {
                    panelHTML += `<div>${warning}</div>`;
                }
                panelHTML += '</div>';
            }

            panel.innerHTML = panelHTML;
        }

        let lastScreenX = 0;
        let lastScreenY = 0;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            lastScreenX = e.clientX - rect.left;
            lastScreenY = e.clientY - rect.top;

            // Transform to canvas coordinates
            const canvasCoords = screenToCanvas(lastScreenX, lastScreenY);
            mouseX = canvasCoords.x;
            mouseY = canvasCoords.y;

            if (selectedAircraft && ghostAircraft) {
                updateGhost();
                updateGhostPanel();
            }
        });

        canvas.addEventListener('click', (e) => {
            if (gameState !== 'ORDER') return;

            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;

            // Transform to canvas coordinates
            const canvasCoords = screenToCanvas(screenX, screenY);
            const clickX = canvasCoords.x;
            const clickY = canvasCoords.y;

            console.log('Click at:', clickX, clickY, 'Ghost active:', !!ghostAircraft, 'State:', ghostAircraft?.state);

            // Check if clicking on an aircraft
            for (let plane of aircraft) {
                if (plane.isClicked(clickX, clickY)) {
                    console.log('Clicked on aircraft:', plane.name);
                    if (!plane.isPlayer) continue; // Only player can control their aircraft

                    if (selectedAircraft === plane) {
                        console.log('Same aircraft - attempting to lock');
                        // Lock in orders
                        if (ghostAircraft && ghostAircraft.state !== 'illegal') {
                            console.log('Locking orders!');
                            plane.lockOrders(
                                ghostAircraft.aircraft.x,
                                ghostAircraft.aircraft.y,
                                ghostAircraft.aircraft.altitude,
                                ghostAircraft.aircraft.heading
                            );
                            selectedAircraft = null; // Deselect but keep ghost visible
                            ghostRotation = 0;
                            ghostAltitudeOffset = 0;
                            document.getElementById('ghostPanel').style.display = 'none';

                            // Generate AI orders
                            generateAIOrders();
                        } else {
                            console.log('Ghost illegal, not locking');
                        }
                    } else if (plane.hasOrders) {
                        console.log('Unlocking orders');
                        // Unlock orders - but recreate ghost at unlocked position
                        plane.unlockOrders();
                        selectedAircraft = plane;
                        ghostAircraft = {
                            aircraft: new Aircraft(plane.name, plane.type, plane.targetX, plane.targetY,
                                plane.targetAltitude, plane.targetHeading, plane.isPlayer),
                            state: 'valid'
                        };
                        ghostRotation = 0;
                        ghostAltitudeOffset = 0;
                        updateGhost();
                    } else {
                        console.log('Selecting aircraft');
                        // Select aircraft
                        selectedAircraft = plane;
                        ghostAircraft = {
                            aircraft: new Aircraft(plane.name, plane.type, plane.x, plane.y,
                                plane.altitude, plane.heading, plane.isPlayer),
                            state: 'valid'
                        };
                        ghostRotation = 0;
                        ghostAltitudeOffset = 0;
                        updateGhost(); // Update ghost immediately
                    }
                    return;
                }
            }

            console.log('Click did not hit aircraft - attempting to lock from anywhere');
            // If we didn't click on any aircraft, but we have a ghost selected, lock in orders
            if (selectedAircraft && ghostAircraft && ghostAircraft.state !== 'illegal') {
                console.log('Locking orders from empty click!');
                selectedAircraft.lockOrders(
                    ghostAircraft.aircraft.x,
                    ghostAircraft.aircraft.y,
                    ghostAircraft.aircraft.altitude,
                    ghostAircraft.aircraft.heading
                );
                selectedAircraft = null; // Deselect but keep ghost visible
                ghostRotation = 0;
                ghostAltitudeOffset = 0;
                document.getElementById('ghostPanel').style.display = 'none';

                // Generate AI orders
                generateAIOrders();
            } else {
                console.log('Cannot lock:', {
                    selectedAircraft: !!selectedAircraft,
                    ghostAircraft: !!ghostAircraft,
                    state: ghostAircraft?.state
                });
            }
        });

        // Keyboard handling
        window.addEventListener('keydown', (e) => {
            if (!selectedAircraft || !ghostAircraft) return;

            switch(e.key.toLowerCase()) {
                case 'w':
                    ghostAltitudeOffset += 50;
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 's':
                    ghostAltitudeOffset -= 50;
                    updateGhost();
                    updateGhostPanel();
                    break;
                case 'a':
                    selectedAircraft.fireThreshold = Math.max(0.1, selectedAircraft.fireThreshold - 0.05);
                    break;
                case 'd':
                    selectedAircraft.fireThreshold = Math.min(0.9, selectedAircraft.fireThreshold + 0.05);
                    break;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            if (selectedAircraft && ghostAircraft) {
                // In maneuver mode: rotate ghost
                if (e.deltaY < 0) {
                    ghostRotation += 10;
                } else {
                    ghostRotation -= 10;
                }
                updateGhost(); // Update ghost immediately after rotation
                updateGhostPanel(); // Update panel to show new heading
            } else {
                // Not in maneuver mode: zoom in/out
                if (e.deltaY < 0) {
                    zoomLevel = Math.min(3.0, zoomLevel * 1.1); // Max 3x zoom
                } else {
                    zoomLevel = Math.max(0.5, zoomLevel / 1.1); // Min 0.5x zoom
                }
            }
        });

        // Execute button
        document.getElementById('executeButton').addEventListener('click', () => {
            gameState = 'EXECUTION';
            executionStartTime = Date.now();
            executionRecording = [];

            // Clear ghost and selection when execution starts
            ghostAircraft = null;
            selectedAircraft = null;
            document.getElementById('ghostPanel').style.display = 'none';

            updateUI();
        });

        document.getElementById('replayButton').addEventListener('click', () => {
            // Replay execution
            gameState = 'EXECUTION';
            executionStartTime = Date.now();
            document.getElementById('replayButton').style.display = 'none';
            document.getElementById('nextPhaseButton').style.display = 'none';

            // Reset aircraft to start of turn positions
            for (let plane of aircraft) {
                plane.x = plane.startX;
                plane.y = plane.startY;
                plane.altitude = plane.startAltitude;
                plane.heading = plane.startHeading;
                plane.speed = plane.startSpeed;
                plane.hasOrders = true;
            }
        });

        document.getElementById('nextPhaseButton').addEventListener('click', () => {
            gameState = 'ORDER';
            currentTurn++;

            // Handle stall recovery/loss of control for next turn
            for (let plane of aircraft) {
                if (plane.inStall) {
                    // Aircraft stalled - lose control this turn (AI takes over recovery)
                    console.log(`${plane.name} is recovering from stall!`);

                    // Auto-generate recovery maneuver: nose down, gain speed
                    const recoveryX = plane.x + Math.cos((plane.heading - 90) * Math.PI / 180) * 200;
                    const recoveryY = plane.y + Math.sin((plane.heading - 90) * Math.PI / 180) * 200;
                    const recoveryAltitude = Math.max(100, plane.altitude - 100); // Lose 100m altitude
                    const recoveryHeading = plane.heading; // Maintain heading during recovery

                    plane.lockOrders(recoveryX, recoveryY, recoveryAltitude, recoveryHeading);
                    plane.inStall = false; // Clear stall for next turn
                    plane.damage += 5; // Damage from stall
                }
            }

            document.getElementById('replayButton').style.display = 'none';
            document.getElementById('nextPhaseButton').style.display = 'none';
            updateUI();
        });

        // Main game loop
        function gameLoop() {
            if (gameState === 'EXECUTION') {
                const elapsed = Date.now() - executionStartTime;
                const progress = Math.min(1, elapsed / EXECUTION_TIME);

                // Move aircraft
                for (let plane of aircraft) {
                    if (plane.hasOrders) {
                        plane.executeOrders(progress);
                    }
                }

                // Process combat
                processCombat();

                if (progress >= 1) {
                    // Finalize execution
                    for (let plane of aircraft) {
                        plane.finalizeExecution();
                    }
                    gameState = 'REVIEW';
                    document.getElementById('replayButton').style.display = 'block';
                    document.getElementById('nextPhaseButton').style.display = 'block';
                }
            }

            render();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        gameLoop();
    </script>
</body>
</html>
